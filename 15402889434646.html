<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Swift中类（Class）和 结构体（Struct） - kaelinda
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="kaelinda" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://ws1.sinaimg.cn/large/006tNc79ly1fmpk9088gsj30sg0sgn33.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">kaelinda</a></h1>
					<p class="subtitle">倘若我心中的山水，你眼中能看到，我便一步一莲花祈祷</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">最近更新</a></li>
						
						  <li id=""><a target="_self" href="archives.html">归档目录</a></li>
						
						  <li id="ios.css"><a target="_self" href="ios.html">iOS</a></li>
						
						  <li id="swift.css"><a target="_self" href="swift.html">Swift</a></li>
						
						  <li id="reactnative.css"><a target="_self" href="reactnative.html">RN</a></li>
						
						  <li id="js.css"><a target="_self" href="js.html">JS</a></li>
						
						  <li id="shell.css"><a target="_self" href="shell.html">shell</a></li>
						
						  <li id="py.css"><a target="_self" href="py.html">Python</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">










<a target="_blank" class="github" target="_blank" href="https://github.com/Kaelzzs" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:zhouzuosong_kael@163.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">Swift中类（Class）和 结构体（Struct）</h1>
		<div class="entry-content" itemprop="articleBody">
			<h2><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h2>
<p>共同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作使得可以通过下标语法来访问实例所包含的值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能</li>
</ul>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用（对象引用）结构体总是通过被复制的方式在代码中传递，不使用引用计数。</li>
</ul>
<h2><a id="%E9%80%90%E4%B8%80%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逐一对比</h2>
<h3><a id="%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义</h3>
<pre><code class="language-plain_text">//: ### 定义
class StudentClass{ }
struct StudebtStruct{ }
</code></pre>
<h3><a id="%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义存储属性</h3>
<pre><code class="language-plain_text">//: &gt; 类中定义的存储属性，如果不是可选类型，需要进行初始化；结构体则默认带有初始化方法
class StudentC01{
    var name: String!
}
struct StudebtS01{
    var name: String!
}
</code></pre>
<h3><a id="%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%87%BD%E6%95%B0function" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义属性函数function</h3>
<p>关于@objc 请参考 <a href="https://blog.csdn.net/qq_35612929/article/details/79563110">Swift 4.0学习之：@objc的使用</a></p>
<pre><code class="language-plain_text">//: ### 定义属性函数function
//: &gt; 类中可以使用 static 和 class两种修饰符；但是结构体中只能使用static修饰
class StudentC02{
    static var des:String = &quot;学生的类&quot;
    var name:String!
    @objc class func objc_describe()-&gt;String{
        return des
    }
    class func class_describe()-&gt;String{
        return des
    }
    static func static_describe()-&gt;String{
        return des
    }
}
struct StudentS02{
    static var des:String = &quot;学生的结构体&quot;
    var name:String!
    static func describe()-&gt;String{
        return &quot;这是一个定义学生的类&quot;
    }
}
</code></pre>
<h3><a id="%E6%89%A9%E5%B1%95%E4%B8%8B%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展下标</h3>
<pre><code class="language-plain_text">//: ### 扩展下标
//: &gt; *subscript*
class StudentC003{
    var names:[String] = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
    subscript (index:Int)-&gt;String?{
        get{
            if names.count &lt;= index{
                return nil
            }
            return names[index]
        }
    }
}
struct StudentS003{
    var names:[String] = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
    subscript (index:Int)-&gt;String?{
        get{
            if names.count &lt;= index{
                return nil
            }
            return names[index]
        }
    }
}
let sc003 = StudentC003()
sc003[1]// 2
let ss003 = StudentS003()
ss003[1]// 2
</code></pre>
<h3><a id="%E5%88%9D%E5%A7%8B%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化</h3>
<pre><code class="language-plain_text">//: ### 初始化
//: &gt; 结构体自带初始化方法（可以不写初始化方法）;
//: &gt; 类必须手写init方法，否则报错；
class StudentC004{
    var name:String
    init(name:String) {
        self.name = name
    }
}
struct StudentS004 {
    var name:String
    
}
let studentc004 = StudentC004(name: &quot;行走在北方&quot;)
let students004 = StudentS004(name: &quot;行走在北方&quot;)
</code></pre>
<h3><a id="%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BDextention" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展功能 Extention</h3>
<pre><code class="language-plain_text">//: ### 扩展功能 Extention
extension StudentC004{
    func discribe() -&gt; String {
        return &quot;student class:&quot;+self.name
    }
}
extension StudentS004{
    func discribe() -&gt; String {
        return &quot;student struct:&quot; + self.name
    }
}
</code></pre>
<h3><a id="%E5%AE%9E%E7%8E%B0%E5%8D%8F%E8%AE%AEprotocol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现协议 protocol</h3>
<pre><code class="language-plain_text">//: ### 实现协议 protocol
//: * 定义协议
protocol Capacity {
    func draw()//协议方法
}
//: * 实现协议方法
class StudentC05:Capacity{
    internal func draw() {
        
    }
    var name:String
    init(name:String) {
        self.name = name
    }
}
struct StudentS05:Capacity{
    internal func draw() {
        
    }
    var name:String
}
</code></pre>
<h3><a id="mutating%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mutating 关键字的使用</h3>
<p>科普下:</p>
<ul>
<li>
<p>枚举和结构体都是值类型，Swift默认值类型的对象方法不能修改属性值,但是如果一定要修改 那就在函数前面添加mutating关键字</p>
</li>
<li>
<p>计算属性setter方法中不需要更改属性值的时候，不需要添加mutating关键字;</p>
</li>
<li>
<p>计算属性setter方法中更改属性值的时候，必须要添加mutating关键字</p>
</li>
</ul>
<pre><code class="language-plain_text">protocol Action{
    var myY:Int{
        mutating get
    }
}
struct Point {
    var x:Int
    var y:Int
    mutating func modifyX(x: Int){
        self.x = x
    }
    var myY:Int{
        mutating get {//getter方法前面添加mutating关键字
            self.y = self.y*2
            return y
        }
    }
}
class ActionClass {
    var name:String?
    init(name:String) {
        self.name = name
    }
    var myName:String? {
        get {// class 是对象类型 可以直接修改
            self.name = &quot;666 -&gt; :&quot; + self.name!
            return self.name
        }
    }
    
}
let actionclass = ActionClass(name: &quot;NB&quot;)
</code></pre>
<h2><a id="%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%88%E9%AA%8C%E8%AF%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断两个对象地址是否相同（验证 引用类型 和 值类型）</h2>
<pre><code class="language-plain_text">//: ### 判断两个对象地址是否相同
//: &gt; 类是引用类型；结构体是值类型；结构体不能通过=== 、！==类判断比较
//: &gt;
class StudentC07{
    var name: String
    init(name:String) {
        self.name = name
    }
}

let studentc071 = StudentC07(name: &quot;原始名字&quot;)
var studentc072 = studentc071
studentc071.name = &quot;新名字&quot;
print(&quot;student071:\(studentc071.name)\nstudent072:\(studentc072.name)&quot;)
if studentc071 === studentc072 {
    print(&quot;类是引用类型，最终指向同一块内存&quot;)
}
struct StudentS07{
    var name: String
    init(name:String) {
        self.name = name
    }
}
let students071 = StudentS07(name: &quot;结构体：原始名字&quot;)
var students072 = students071
students072.name = &quot;结构体：新名字&quot;
print(&quot;students071:\(students071.name)\nstudents072\(students072.name)&quot;)
</code></pre>
<h3><a id="deinit%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>deinit 释放资源</h3>
<p><a href="https://www.jianshu.com/p/9e725362eeb1">Swift中的deinit方法</a></p>
<pre><code class="language-plain_text">//: ### deinit 释放资源
//: &gt; 类有deinit方法；结构体中没有deinit方法。
class StudentC08{
    var name: String
    init(name:String) {
        self.name = name
    }
    deinit {
        //这里释放资源
    }
}
</code></pre>
<h3><a id="lazy%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%B1%9E%E6%80%A7%EF%BC%88%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lazy：延迟属性（懒加载）</h3>
<p>class 有延迟属性；struct没有延迟属性</p>
<pre><code class="language-plain_text">//: &gt; 延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标示一个延迟存储属性
class Importor{
    var fileName = &quot;data.txt&quot;
}
class DataManager{
    lazy var importor = Importor()
    var Data = [String]()
}
</code></pre>
<h3><a id="%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承</h3>
<pre><code class="language-plain_text">//: ### 继承
//: &gt; 类能继承；结构体不能继承。
class Person{
    var name:String
    init(name:String) {
        self.name = name
    }
}
class Student06: Person {
    var score : Float
    init(name: String, score: Float){
        self.score = score//先给父类中没有的属性赋值，再调用父类init方法
        super.init(name: name)
    }
}   
</code></pre>
<ul>
<li>
<p>继承之后 可重写父类方法/属性</p>
<ol>
<li>
<p>重写计算属性：只能增加功能不能减少功能——&gt;父类中有setter getter,那么子类重写计算属性 setter getter都必须要有。父类中只有setter  子类中可以在重写setter的同时增加getter</p>
</li>
<li>
<p>final 关键字可以让属性不被重写 或者 继承</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-plain_text">//: * 重写计算属性
//: * 重写对象方法
//: * 重写类方法
//: * 重写初始化方法
//: * 重写存储属性

//: _父类_
class Person{
    //存储属性
    var name:String = &quot;person&quot;
    //计算属性
    var rename:String{
        return self.name
    }
    //初始化方法
    init(_ name:String) {
        self.name = name
    }
    //对象方法
    func describe() -&gt; String {
        return self.name
    }
    //类方法
    class func describeClass()-&gt;String{
        return &quot;这是一个描述人的类&quot;
    }
}
//: _子类_
class Man: Person {
    //重写存储属性
    override var name: String{
        didSet{
            print(&quot;man 对象中 name 的原始值：\(self.name)&quot;)
            self.name = &quot;man:&quot;+self.name
        }
    }
    var score : Double
    //重写setter getter
    override var rename: String{
        set{
            self.name = &quot;man:&quot;+newValue
        }
        get{
            return &quot;_&quot;+self.name
        }
    }
    //重写初始化方法
    override init(_ name: String) {
        self.score = 0.0
        super.init(name)
    }
    //重写对象方法
    override func describe() -&gt; String {
        return self.name + &quot;_score:\(self.score)&quot;
    }
    // 重写类方法
    override class func describeClass() -&gt; String {
        return &quot;我是描述男人的类&quot;
    }
}
var man00 = Man(&quot;kael&quot;)
print(man00.name)
</code></pre>
<h3><a id="class%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>class 的类型检测</h3>
<ol>
<li>首先在自己的初始化方法中先给自己的属性初始化</li>
<li>然后调用父类的初始化</li>
<li>最后修改父类的属性</li>
</ol>
<pre><code class="language-plain_text">//: ### 类型检测  is  as?
var person01 = Person(&quot;person01&quot;)
var man01 = Man(&quot;man01&quot;)

if person01 is Person {
    print(&quot;person01：我是Person&quot;)
}else{
    print(&quot;person01：我不是Person&quot;)
}
if person01 is Man {
    print(&quot;person01：我是Man&quot;)
}else{
    print(&quot;person01：我不是Man&quot;)
}
if man01 is Person {
    print(&quot;man01：我是Person&quot;)
}else{
    print(&quot;man01：我不是Person&quot;)
}
if man01 is Man {
    print(&quot;man01：我是Man&quot;)
}else{
    print(&quot;man01：我不是Man&quot;)
}

if let p = person01 as? Person {
    print(&quot;person01 是 Person&quot;)
}
if let p = person01 as? Man{
    print(&quot;person01 是Man&quot;)
}else{
    print(&quot;person01 不是Man&quot;)
}
if let p = man01 as? Person {
    print(&quot;man01 是 Person&quot;)
}
if let p = man01 as? Man{
    print(&quot;man01 是Man&quot;)
}else{
    print(&quot;man01 不是Man&quot;)
}


</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 1em 0;padding: 0;}
  figcaption{text-align:center;}

/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-coy&languages=markup+css+clike+javascript */
/**
 * prism.js Coy theme for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/tshedor/workshop-wp-theme (Example: http://workshop.kansan.com/category/sessions/basics or http://workshop.timshedor.com/category/sessions/basics);
 * @author Tim  Shedor
 */

code[class*="language-"],
pre[class*="language-"] {
  color: black;
  background: none;
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  position: relative;
  margin: .5em 0;
  overflow: visible;
  padding: 0;
}
pre[class*="language-"]>code {
  position: relative;
  border-left: 10px solid #358ccb;
  box-shadow: -1px 0px 0px 0px #358ccb, 0px 0px 0px 1px #dfdfdf;
  background-color: #fdfdfd;
  background-image: linear-gradient(transparent 50%, rgba(69, 142, 209, 0.04) 50%);
  background-size: 3em 3em;
  background-origin: content-box;
  background-attachment: local;
}

code[class*="language"] {
  max-height: inherit;
  height: inherit;
  padding: 0 1em;
  display: block;
  overflow: auto;
}

/* Margin bottom to accomodate shadow */
:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdfdfd;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  margin-bottom: 1em;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  position: relative;
  padding: .2em;
  border-radius: 0.3em;
  color: #c92c2c;
  border: 1px solid rgba(0, 0, 0, 0.1);
  display: inline;
  white-space: normal;
}

pre[class*="language-"]:before,
pre[class*="language-"]:after {
  content: '';
  z-index: -2;
  display: block;
  position: absolute;
  bottom: 0.75em;
  left: 0.18em;
  width: 40%;
  height: 20%;
  max-height: 13em;
  box-shadow: 0px 13px 8px #979797;
  -webkit-transform: rotate(-2deg);
  -moz-transform: rotate(-2deg);
  -ms-transform: rotate(-2deg);
  -o-transform: rotate(-2deg);
  transform: rotate(-2deg);
}

:not(pre) > code[class*="language-"]:after,
pre[class*="language-"]:after {
  right: 0.75em;
  left: auto;
  -webkit-transform: rotate(2deg);
  -moz-transform: rotate(2deg);
  -ms-transform: rotate(2deg);
  -o-transform: rotate(2deg);
  transform: rotate(2deg);
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #7D8B99;
}

.token.punctuation {
  color: #5F6364;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.function-name,
.token.constant,
.token.symbol,
.token.deleted {
  color: #c92c2c;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.function,
.token.builtin,
.token.inserted {
  color: #2f9c0a;
}

.token.operator,
.token.entity,
.token.url,
.token.variable {
  color: #a67f59;
  background: rgba(255, 255, 255, 0.5);
}

.token.atrule,
.token.attr-value,
.token.keyword,
.token.class-name {
  color: #1990b8;
}

.token.regex,
.token.important {
  color: #e90;
}

.language-css .token.string,
.style .token.string {
  color: #a67f59;
  background: rgba(255, 255, 255, 0.5);
}

.token.important {
  font-weight: normal;
}

.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}

.namespace {
  opacity: .7;
}

@media screen and (max-width: 767px) {
  pre[class*="language-"]:before,
  pre[class*="language-"]:after {
    bottom: 14px;
    box-shadow: none;
  }

}

/* Plugin styles */
.token.tab:not(:empty):before,
.token.cr:before,
.token.lf:before {
  color: #e0d7d1;
}

/* Plugin styles: Line Numbers */
pre[class*="language-"].line-numbers.line-numbers {
  padding-left: 0;
}

pre[class*="language-"].line-numbers.line-numbers code {
  padding-left: 3.8em;
}

pre[class*="language-"].line-numbers.line-numbers .line-numbers-rows {
  left: 0;
}

/* Plugin styles: Line Highlight */
pre[class*="language-"][data-line] {
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 0;
}
pre[data-line] code {
  position: relative;
  padding-left: 4em;
}
pre .line-highlight {
  margin-top: 0;
}

pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>
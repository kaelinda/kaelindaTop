<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Kaelinda]]></title>
  <link href="http://kaelinda.top/atom.xml" rel="self"/>
  <link href="http://kaelinda.top/"/>
  <updated>2021-10-12T00:21:09+08:00</updated>
  <id>http://kaelinda.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS OpenURL方式吊起APP]]></title>
    <link href="http://kaelinda.top/16337448805296.html"/>
    
    <updated>2021-10-09T10:01:20+08:00</updated>
    <id>http://kaelinda.top/16337448805296.html</id>
    <content type="html"><![CDATA[
    <img src="https://feng-bbs-att-1255531212.image.myqcloud.com/2021/10/07/105645mvq8zfwfkm922idb.1-Feature-Green-1.jpg?imageMogr2/format/jpg/interlace/0/quality/100" />
<p>[toc]</p>
<h1><a id="%E8%83%8C%E6%99%AF%E6%8F%8F%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背景描述</h1>
<p>假如我们有两个项目，一个是我们的主项目<code>MainProject</code>，要通过系统提供的API <code>OpenURL：</code>方式吊起另外的项目<code>OtherProject</code>。</p>
<h1><a id="otherproject%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OtherProject项目配置</h1>
<p><a href="https://www.jianshu.com/p/7a308f5b89fc">参考：iOS App 唤醒另一个App</a></p>
<span id="more"></span><!-- more -->
<h2><a id="%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E7%9A%84scheme" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置支持的scheme</h2>
<p>可以在info的 URL Type中配置,也可以直接在info.plist文件中修改</p>
<p><figure><img src="https://upload-images.jianshu.io/upload_images/664334-1e373d2a61fad1d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="" /></figure></p>
<p><figure><img src="https://upload-images.jianshu.io/upload_images/664334-b76eec163e50ba46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/486/format/webp" alt="" /></figure></p>
<ul>
<li><code>URL identifier</code>只是一个区分不同scheme的唯一标示符，只要能唯一区分可随意填写，建议写成：<code>com.tencent.wechat</code>反转域名的方法保证该名字的唯一性</li>
<li><code>URL Scheme</code> 就是你用来通信的命令前缀,用来定位一个应用。</li>
</ul>
<h2><a id="%E9%85%8D%E7%BD%AE%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置接收信息的代码</h2>
<pre><code class="language-objc">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url 
        sourceApplication:(NSString *)sourceApplication annotation:(id)annotation 
{ 
  NSLog(@&quot;Calling Application Bundle ID: %@&quot;, sourceApplication); 
  NSLog(@&quot;URL scheme:%@&quot;, [url scheme]); 
  NSLog(@&quot;URL query: %@&quot;, [url query]); 
 
// Customer Code
  return YES; 
} 
</code></pre>
<ul>
<li>A: <code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url NS_DEPRECATED_IOS(2_0, 9_0, &quot;Please use application:openURL:options:&quot;) __TVOS_PROHIBITED</code>;</li>
<li>B: <code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation NS_DEPRECATED_IOS(4_2, 9_0, &quot;Please use application:openURL:options:&quot;) __TVOS_PROHIBITED;</code></li>
<li>C: <code>- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options NS_AVAILABLE_IOS(9_0);</code> // no equiv. notification. return NO if the application can't open for some reason</li>
</ul>
<p>3个回调的功能基本一样，都是在别人通过URL Schemes打开应用的时候会执行的。
这几个回调是有优先级的。C&gt;B&gt;A。也就是说，如果你3个回调都实现了，那么程序只会执行C回调。其他回调是不会执行的。（当然，iOS9以下只会执行B回调）。</p>
<p>由于目前市面上的绝大多数APP都是支持到iOS7.0以上的 所以 推荐 实现B接口，A可以忽略。</p>
<h1><a id="mainproject%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%92%8C%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MainProject项目配置和操作</h1>
<h2><a id="%E5%94%A4%E8%B5%B7%E7%9B%AE%E6%A0%87app%E7%9A%84%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>唤起目标APP的代码</h2>
<pre><code class="language-objc">/// 是否能打开指定scheme的APP
+ (BOOL)_isInstalled_iPadeAppWithOpenURL {
    return [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:kAppSchemeForIPad]];
}
/// 呼起APP
+ (void)_callUpHDAppWithOpenURL:(NSString *)openURL {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:openURL]];
}
</code></pre>
<h2><a id="%E7%99%BD%E5%90%8D%E5%8D%95%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>白名单配置</h2>
<ul>
<li><code>LSApplicationQueriesSchemes</code> iOS9之后提高了app的安全性，需要给出一个类似白名单的东西，在白名单里面的才能打开app。不然报错：</li>
</ul>
<blockquote>
<p>-canOpenURL: failed for URL: &quot;OpenAppTest://mark?id=007&quot; - error: &quot;This app is not allowed to query for scheme OpenAppTest&quot;</p>
</blockquote>
<ul>
<li><code>LSApplicationQueriesSchemes</code>顺序问题，iOS 15前50个scheme白名单有效。所以，可以通过调整顺序的方式将重要的scheme放到前面。</li>
</ul>
<blockquote>
<p>经测试，目前只影响 <code>canOpenURL:</code> 的判断 不配置 LSApplicationQueriesSchemes 或者 放置的顺序 &gt;= 50 ,<code>canOpenURL</code> return NO；不影响 <code>openURL:</code> 对 <code>OtherProject</code> 的吊起。</p>
</blockquote>
<p><figure><img src="https://upload-images.jianshu.io/upload_images/664334-a6a13ba493d4b249.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp" alt="LSApplicationQueriesSchemes配置" /><figcaption>LSApplicationQueriesSchemes配置<figcaption></figure></p>
<p><figure><img src="https://upload-images.jianshu.io/upload_images/412206-55a3d996e5b825da.png?imageMogr2/auto-orient/strip%257CimageView2/2/w/1240" alt="iOS 15前50个scheme白名单有效" /><figcaption>iOS 15前50个scheme白名单有效<figcaption></figure></p>
<p>常用URL Scheme</p>
<table>
<thead>
<tr>
<th>APP</th>
<th>scheme</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFT</td>
<td>prefs:root=WIFI</td>
</tr>
<tr>
<td>蜂窝数据</td>
<td>prefs:root=MOBILE_DATA_SETTINGS_ID://</td>
</tr>
<tr>
<td>电池</td>
<td>prefs:root=BATTERY_USAGE://</td>
</tr>
<tr>
<td>VPN</td>
<td>prefs:root=General&amp;path=VPN://</td>
</tr>
<tr>
<td>QQ</td>
<td>mqq://</td>
</tr>
<tr>
<td>WeiBo</td>
<td>weibo://</td>
</tr>
<tr>
<td>Wechat</td>
<td>wechat://</td>
</tr>
<tr>
<td>支付宝</td>
<td>alipay://</td>
</tr>
<tr>
<td>Facebook</td>
<td>fb://</td>
</tr>
<tr>
<td>Twitter</td>
<td>twitter://</td>
</tr>
<tr>
<td>Google Chrome</td>
<td>googlechrome://</td>
</tr>
<tr>
<td>Medium</td>
<td>medium://</td>
</tr>
<tr>
<td>Quora</td>
<td>quora://</td>
</tr>
<tr>
<td>知乎</td>
<td>zhihu://</td>
</tr>
<tr>
<td>Uber</td>
<td>uber://</td>
</tr>
<tr>
<td>简书</td>
<td>jianshu://</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 打开别的APP的两种Native方法]]></title>
    <link href="http://kaelinda.top/16336873755362.html"/>
    
    <updated>2021-10-08T18:02:55+08:00</updated>
    <id>http://kaelinda.top/16336873755362.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h1><a id="open-url" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Open URL</h1>
<h2><a id="%E5%88%A4%E6%96%AD%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断安装</h2>
<pre><code class="language-objc">/// 是否能打开指定scheme的APP
+ (BOOL)_isInstalled_iPadeAppWithOpenURL {
    return [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:kAppSchemeForIPad]];
}
</code></pre>
<h2><a id="%E5%90%8A%E8%B5%B7app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>吊起APP</h2>
<pre><code class="language-objc">/// 呼起APP
+ (void)_callUpHDAppWithOpenURL:(NSString *)openURL {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:openURL]];
}
</code></pre>
<span id="more"></span><!-- more -->
<h1><a id="bundleid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>bundleID</h1>
<h2><a id="%E9%80%9A%E8%BF%87bundleid%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9Aapp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通过bundleID检测是否已安装指定APP</h2>
<pre><code class="language-objc">/// 是否已安装指定bundleID的APP
+ (BOOL)_isInstalled_iPadeAppWithBundleID {
    return [self verifyAppWithBundle:kAppBundleIDForIPad];
}

+ (BOOL)verifyAppWithBundle:(NSString *)bundleID{

    __block BOOL isInstall = NO;

    //iOS12间接获取办法
    if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 12.0){
        Class lsawsc = objc_getClass(&quot;LSApplicationWorkspace&quot;);

        NSObject* workspace = [lsawsc performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];

        NSArray *plugins = [workspace performSelector:NSSelectorFromString(@&quot;installedPlugins&quot;)];
        //列出所有plugins


        [plugins enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {

            NSString *pluginID = [obj performSelector:(@selector(pluginIdentifier))];
            // NSLog(@&quot;kael-- bundleid :%@&quot;,pluginID);
            if([pluginID containsString:bundleID]){
                isInstall = YES;
                return;
            }
        }];

        return isInstall;

    } else if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 11.0) {

           //iOS11获取办法
           NSBundle *container = [NSBundle bundleWithPath:@&quot;/System/Library/PrivateFrameworks/MobileContainerManager.framework&quot;];

           if ([container load]) {

                 Class appContainer = NSClassFromString(@&quot;MCMAppContainer&quot;);

                 id test = [appContainer performSelector:@selector(containerWithIdentifier:error:) withObject:bundleID withObject:nil];

                 NSLog(@&quot;%@&quot;,test);

                 if (test) {
                      return YES;
                  } else {
                      return NO;
                    }

            }else{
                return NO;
            }


    }else{

        //iOS10及以下获取办法
        Class lsawsc = objc_getClass(&quot;LSApplicationWorkspace&quot;);
        NSObject* workspace = [lsawsc performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];
        NSArray *appList = [workspace performSelector:@selector(allApplications)];
        Class LSApplicationProxy_class = object_getClass(@&quot;LSApplicationProxy&quot;);

        for (LSApplicationProxy_class in appList) {

            //这里可以查看一些信息
            NSString *bundleID = [LSApplicationProxy_class performSelector:@selector(applicationIdentifier)];
            NSString *version =  [LSApplicationProxy_class performSelector:@selector(bundleVersion)];
            NSString *shortVersionString =  [LSApplicationProxy_class performSelector:@selector(shortVersionString)];
            if ([bundleID isEqualToString:bundleID]) {
                return  YES;
            }

        }

        return NO;
    }

    return NO;
}
</code></pre>
<h2><a id="%E9%80%9A%E8%BF%87bundleid%E5%91%BC%E8%B5%B7app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通过bundleID呼起APP</h2>
<pre><code class="language-objc">+ (BOOL)_callUpAppWithBundle:(NSString *)bundleID {
    
    Class LSApplicationWorkspace_class = NSClassFromString([@&quot;LSApplicati&quot; stringByAppendingString:@&quot;onWorkspace&quot;]);
    SEL defaultWspc = NSSelectorFromString([@&quot;defaultW&quot; stringByAppendingString:@&quot;orkspace&quot;]);
    SEL opensdasadkl = NSSelectorFromString([@&quot;openApplicatio&quot; stringByAppendingString:@&quot;nWithBundleID:&quot;]);
    NSObject * workspace = [LSApplicationWorkspace_class performSelector:defaultWspc];
    BOOL isopen = [workspace performSelector:opensdasadkl withObject:bundleID];
 
    return isopen;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode【算法】宝石与石头]]></title>
    <link href="http://kaelinda.top/16336627926129.html"/>
    
    <updated>2021-10-08T11:13:12+08:00</updated>
    <id>http://kaelinda.top/16336627926129.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<blockquote>
<p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
</blockquote>
<blockquote>
<p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;
输出: 3
示例 2:
输入: J = &quot;z&quot;, S = &quot;ZZ&quot;
输出: 0</p>
</blockquote>
<p><strong>注意:</strong></p>
<p><strong>S 和 J 最多含有50个字母。
J 中的字符不重复。</strong></p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常规操作</h2>
<pre><code class="language-plain_text">func numJewelsInStones(_ J: String, _ S: String) -&gt; Int {
   var gemNum:Int = 0

   for jew in J.characters {
       for stone in S.characters {
           if stone == jew {
               gemNum = gemNum + 1
           }
       }
   }
   return gemNum
}
</code></pre>
<table>
<thead>
<tr>
<th>执行时间</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>28ms</td>
<td>19.1M</td>
</tr>
</tbody>
</table>
<h2><a id="%E4%BC%98%E5%8C%96%E5%90%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化后</h2>
<pre><code class="language-plain_text"> func numJewelsInStones(_ J: String, _ S: String) -&gt; Int {
    var gemNum:Int = 0
    for jew in J {
        for stone in S {
            if stone == jew {
                gemNum = gemNum + 1
            }
        }
    }
    return gemNum

}
</code></pre>
<table>
<thead>
<tr>
<th>执行时间</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>16ms</td>
<td>19.5MB</td>
</tr>
</tbody>
</table>
<h2><a id="%E8%80%83%E8%99%91%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>考虑尽量减少中间变量</h2>
<pre><code class="language-plain_text">func numJewelsInStones(_ J: String, _ S: String) -&gt; Int {

    var newS = S
    for jew in J.characters {
       newS = newS.replacingOccurrences(of: &quot;\(jew)&quot;, with: &quot;&quot;)
    }

    return S.count - newS.count
}
</code></pre>
<table>
<thead>
<tr>
<th>执行时间</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>52ms</td>
<td>20.5M</td>
</tr>
</tbody>
</table>
<h2><a id="%E5%87%8F%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>减少字符串操作</h2>
<pre><code class="language-plain_text">func numJewelsInStones(_ J: String, _ S: String) -&gt; Int {
    var jewNum:Int = 0;
    for stone in S {
        if J.contains(stone) {
            jewNum = jewNum + 1;
        }
    }
    return jewNum;
}
</code></pre>
<table>
<thead>
<tr>
<th>执行时间</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>40ms</td>
<td>18.9MB</td>
</tr>
</tbody>
</table>
<h2><a id="%E8%80%83%E8%99%91%E5%B0%91%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E7%9A%84function" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>考虑少用字符串比较的Function</h2>
<pre><code class="language-plain_text">func numJewelsInStones(_ J: String, _ S: String) -&gt; Int {
    var jewNum:Int = 0;
    var jSet = Set&lt;Character&gt;();
    for jew in J {
        jSet.insert(jew)
    }
    for stone in S {
        if jSet.contains(stone) {
            jewNum = jewNum + 1;
        }
    }
    return jewNum;
}
</code></pre>
<table>
<thead>
<tr>
<th>执行时间</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td>16ms</td>
<td>19.3M</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView 嵌套tableView吸顶 手势冲突问题解决方案以及优化（一 解决）]]></title>
    <link href="http://kaelinda.top/16336627158241.html"/>
    
    <updated>2021-10-08T11:11:55+08:00</updated>
    <id>http://kaelinda.top/16336627158241.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%AF%E4%BB%A5%E8%AF%86%E5%88%AB%E5%A4%9A%E4%B8%AA%E6%89%8B%E5%8A%BF%E7%9A%84containertableview%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84-tableview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义的 可以识别多个手势的 ContainerTableView 最外层的tableView</h2>
<pre><code class="language-plain_text">@interface LXContainerTableView : UITableView

@end
</code></pre>
<pre><code class="language-plain_text">/**
 同时识别多个手势
 */
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if ([otherGestureRecognizer.view isKindOfClass:NSClassFromString(@&quot;UILayoutContainerView&quot;)]) {
        if (otherGestureRecognizer.state == UIGestureRecognizerStateBegan &amp;&amp; self.contentOffset.x == 0) {
            return NO;
        }
    }
    return YES;
}
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    if (self.tableHeaderView &amp;&amp; CGRectContainsPoint(self.tableHeaderView.frame, point)) {
        return NO;
    }
    return [super pointInside:point withEvent:event];
}
</code></pre>
<h2><a id="mainpagevc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mainPageVC</h2>
<h3><a id="%E5%88%9D%E5%A7%8B%E5%8C%96maintableview%E6%97%B6%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%8F%AF%E6%BB%91%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化 mainTableView 时，默认可滑动</h3>
<pre><code class="language-plain_text">-(LXContainerTableView *)mainTableView{
    if (!_mainTableView) {
        // 是否可mainTableView滑动
        _canScroll = YES;
        _mainTableView = [[LXContainerTableView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT - kiphonexBottom) style:UITableViewStylePlain];
        _mainTableView.delegate = self;
        _mainTableView.dataSource = self;
        _mainTableView.backgroundColor = [UIColor getBackgroundColor];
        _mainTableView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0);
        _mainTableView.showsVerticalScrollIndicator = NO;
        
        _mainTableView.tableHeaderView = self.headerView;
        if (@available(iOS 11.0, *)) {
            _mainTableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
        } else {
            self.automaticallyAdjustsScrollViewInsets = NO;
        }
        
        _mainTableView.tableFooterView = self.footerView;
    }
    return _mainTableView;
}
</code></pre>
<h3><a id="matableviewvc%E4%B8%AD-scrollviewdisscroll%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%AD%E5%91%8A%E7%9F%A5%E5%AD%90%E8%A7%86%E5%9B%BE%EF%BC%9A%E7%88%B6%E8%A7%86%E5%9B%BE%E5%B7%B2%E7%BB%8F%E5%90%B8%E9%A1%B6%EF%BC%8C%E5%AD%90%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%BB%91%E5%8A%A8%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>matableViewVC 中 scrollViewDisScroll 代理方法中 告知子视图：父视图已经吸顶，子视图可以滑动了</h3>
<pre><code class="language-plain_text">- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
   
    if (scrollView == self.mainTableView) {
        // 调整 导航条的透明度
        CGFloat alpha = self.mainTableView.contentOffset.y/100.f;
        [self.navBarView updateAlpha:alpha];
        //
        CGFloat maxOffset = self.headerView.height - kNavigationBarH;
        if (self.mainTableView.contentOffset.y &gt; maxOffset) {
            scrollView.contentOffset = CGPointMake(0, maxOffset);
            
            _canScroll = NO;
            // header 已经滑动到顶部，让子视图可以滚动
            [self headerScrollToTop];
            
        }else{

            if (!_canScroll) {
                self.mainTableView.contentOffset = CGPointMake(0, maxOffset);
            }
        }
        
    }
    
}

// ---  header 已经滑动到顶部，让子视图可以滚动
-(void)headerScrollToTop{
        [self.baseInfoVC sectionHeaderToTopChildVCScroll:YES];
        [self.courseVC sectionHeaderToTopChildVCScroll:YES];
}
</code></pre>
<h2><a id="%E5%AD%90vc%E7%9A%84basevc%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子VC的baseVC内容</h2>
<h3><a id="%E5%AD%90vc%E7%9A%84basevc%E7%9A%84-h%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子VC的baseVC 的 .h文件</h3>
<pre><code class="language-plain_text">```
@interface LXTeacherTabBaseVC : LXBaseViewController&lt;UIScrollViewDelegate,UITableViewDelegate,UITableViewDataSource&gt;

/** 通知父scrollView 取消吸顶 */
@property (nonatomic,copy) void (^ leaveTopAction)(BOOL canScroll);
/** 嵌套的scrollView的子View */
@property (nonatomic, strong) UIScrollView *baseScrollView;
/** 子scrollView视图 是否可滑动 */
@property (nonatomic, assign) BOOL canScroll;

/** mainTableView 的 header 已经滑动到顶部，让子视图可以滚动 */
-(void)sectionHeaderToTopChildVCScroll:(BOOL)canScroll;

/** 重新加载数据【网路数据重新加载】 */
-(void)reloadData;

@end
```
</code></pre>
<h3><a id="%E5%AD%90vc%E7%9A%84basevc%E7%9A%84-m%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子VC的baseVC 的 .m文件</h3>
<pre><code class="language-plain_text">```
// 设置基础scrollView
-(void)setBaseScrollView:(UIScrollView *)baseScrollView{
    _baseScrollView = baseScrollView;
    _baseScrollView.scrollEnabled = YES;
}
// 控制子视图滑动功能的开启
-(void)sectionHeaderToTopChildVCScroll:(BOOL)canScroll{
    if (canScroll) {
        self.baseScrollView.scrollEnabled = YES;
        self.baseScrollView.showsVerticalScrollIndicator = YES;
        _canScroll = YES;
    }
}

- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    if (scrollView == self.baseScrollView) {
        CGFloat offsetY = scrollView.contentOffset.y;
        if (!_canScroll) {
            [scrollView setContentOffset:CGPointZero];
        }
        if (offsetY &lt;= 0) {
            _canScroll = NO;
            if (self.leaveTopAction) {
                self.leaveTopAction(YES);
            }
        }
        self.baseScrollView.showsVerticalScrollIndicator = _canScroll;
    }
}
```
</code></pre>
<h2><a id="maintablevc%E4%B8%AD%E6%8D%95%E8%8E%B7%E5%AD%90%E8%A7%86%E5%9B%BE%E7%9A%84%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mainTableVC 中 捕获子视图的回调方法</h2>
<pre><code class="language-plain_text">```
// 分别设置子视图的回调
_baseInfoVC.leaveTopAction = ^(BOOL canScroll) {
        [wself childVCLeaveTopMainTableEnableScroll:canScroll];
    };    
    
// 统一处理回调
#pragma mark ------- subVC callback
-(void)childVCLeaveTopMainTableEnableScroll:(BOOL)canScroll{
    self.canScroll = YES;
}
```
</code></pre>
<h2><a id="basevc%E7%9A%84%E5%AD%90%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>baseVC的 <code>子类</code></h2>
<h3><a id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AEbasescrollview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化时候设置baseScrollView</h3>
<pre><code class="language-plain_text">```
self.baseScrollView = self.tableView;
```

or

```
self.baseScrollView = _scrollView;
```
</code></pre>
<p>##【上下滑 左右滑 冲突解决】</p>
<pre><code class="language-plain_text">-(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{
    if (scrollView == self.swipScrollView) {
        self.mainTableView.scrollEnabled = NO;
    }
    if (scrollView == self.mainTableView) {
        self.swipScrollView.scrollEnabled = NO;
    }
}

-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{
    if (scrollView == self.swipScrollView) {
        self.mainTableView.scrollEnabled = YES;
    }
    if (scrollView == self.mainTableView) {
        self.swipScrollView.scrollEnabled = YES;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton 点击事件响应延迟 问题解决]]></title>
    <link href="http://kaelinda.top/16336626850108.html"/>
    
    <updated>2021-10-08T11:11:25+08:00</updated>
    <id>http://kaelinda.top/16336626850108.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<ul>
<li>问题表现</li>
</ul>
<blockquote>
<p>我在UITableView的Header上添加了一个视图（FiltersView），FiltersView上面添加了不定数量的 UIButton。点击UIButton 字体颜色和 layer 的 border 颜色发生改变。但是，当我快速点击快速抬起的时候，发现按钮颜色和border的颜色并没有发生改变；只有在手指停留在屏幕上的时间稍长一点的时候才会有响应事件触发。</p>
</blockquote>
<ul>
<li>点击之前的效果</li>
</ul>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1o488onwdj30f803qgln.jpg" alt="这是点击前的效果" /><figcaption>这是点击前的效果<figcaption></figure></p>
<ul>
<li>点击之后应该有的效果
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1o48y5ck6j30fc03a3yj.jpg" alt="点击之后应该有的效果" /><figcaption>点击之后应该有的效果<figcaption></figure></li>
</ul>
<ul>
<li>问题分析
响应事件延迟有两种情况：</li>
</ul>
<span id="more"></span><!-- more -->
<ul>
<li>
<p>#####1. UIButton 的event事件调用错误</p>
<p>在这个网友的日志里看到一些内容，大体如下：</p>
</li>
</ul>
<pre><code class="language-plain_text">UIControlEventTouchDown  
单点触摸按下事件：用户点触屏幕，或者又有新手指落下的时候。
UIControlEventTouchDownRepeat  
多点触摸按下事件，点触计数大于1：用户按下第二、三、或第四根手指的时候。
UIControlEventTouchDragInside  
当一次触摸在控件窗口内拖动时。  
UIControlEventTouchDragOutside  
当一次触摸在控件窗口之外拖动时。  
UIControlEventTouchDragEnter  
当一次触摸从控件窗口之外拖动到内部时。  
UIControlEventTouchDragExit  
当一次触摸从控件窗口内部拖动到外部时。  
  

	  
	UIControlEventTouchUpInside  
所有在控件之内触摸抬起事件。  
UIControlEventTouchUpOutside  
所有在控件之外触摸抬起事件(点触必须开始与控件内部才会发送通知)。  
UIControlEventTouchCancel  
所有触摸取消事件，即一次触摸因为放上了太多手指而被取消，或者被上锁或者电话呼叫打断。  
UIControlEventTouchChanged  
当控件的值发生改变时，发送通知。用于滑块、分段控件、以及其他取值的控件。你可以配置滑块控件何时发送通知，在滑块被放下时发送，或者在被拖动时发送。  
UIControlEventEditingDidBegin  
当文本控件中开始编辑时发送通知。  
UIControlEventEditingChanged  
当文本控件中的文本被改变时发送通知。  
UIControlEventEditingDidEnd  
当文本控件中编辑结束时发送通知。  
UIControlEventEditingDidOnExit  
当文本控件内通过按下回车键（或等价行为）结束编辑时，发送通知。  
UIControlEventAlltouchEvents  
通知所有触摸事件。  
UIControlEventAllEditingEvents  
通知所有关于文本编辑的事件。  
UIControlEventAllEvents  
通知所有事件。
</code></pre>
<ul>
<li>####2.父试图拦截了触摸事件 （手势冲突，或者交互的别的什么原因）<br />
经过多方查证，可能造成父试图拦截的情况分别是 UIScrollVIew 和UITableView。系统默认<em><strong>delaysTouchesBegan</strong></em> 属性为YES, 设置 <em><strong>delaysTouchesBegan</strong></em> 属性 为NO即可解决延时响应问题。</li>
</ul>
<p>####<strong>原因</strong>：
iOS 7+系统 ，手触摸到屏幕后系统会有 150ms的时间去反应并判断，你是否是正常点击和不经意间的点击。手触摸屏幕时间超过 150ms UIScrollView 或者UITableView  才会把触摸事件分发给各个子视图。否则，会被其拦截。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC基础知识总结 一]]></title>
    <link href="http://kaelinda.top/16336626477924.html"/>
    
    <updated>2021-10-08T11:10:47+08:00</updated>
    <id>http://kaelinda.top/16336626477924.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h1><a id="%E4%B8%80%E3%80%81nsobject%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、 NSobject对象</h1>
<ol>
<li><code>NSobject</code>的本质类型是基于c,c++的<code>结构体</code>形式</li>
<li>系统分配了16个字节NSobject对象（通过malloc_size函数获得），但是内部只使用8个字节的空间(64bit环境下，通过class_getInstanceSize函数获得)，class_getInstanceSize创建类需要的大小，malloc_size实际分配的大小</li>
<li>Objective-C中的对象，简称OC对象，主要可以分为3种：instance对象（实例对象）、class对象（类对象）、meta-class对象（元类对象）</li>
<li>instance的isa指向class：当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用
class的isa指向meta-class：当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用：meta-class对象的isa指向基类的meta-class对象<br />
class的superclass指向父类的class：如果没有父类，superclass指针为nil
meta-class的superclass指向父类的meta-class：基类的meta-class的superclass指向基类的class
instance调用对象方法的轨迹：isa找到class，方法不存在，就通过superclass找父类
class调用类方法的轨迹：isa找meta-class，方法不存在，就通过superclass找父类
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1od3zosiej30la096my6.jpg" alt="" /></figure></li>
<li>struct objc_class的结构
<figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1od4jatf6j30n20aqabv.jpg" alt="" /></figure></li>
</ol>
<h1><a id="%E4%BA%8C%E3%80%81kvo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、 KVO</h1>
<ol>
<li>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</li>
<li>为啥会被修改属性值会被监听到，本质是对象指向类的对象变化(runtime动态生成的)，isa指向了NSnotifying_...然后去找Foundtion框架的_NSSet...ValueAndNotify函数
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1plgvu9w8j30n20b4wfu.jpg" alt="" /></figure></li>
<li>_NSSet*ValueAndNotify的内部实现
willChangeValueForKey:
父类原来的setter
didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法</li>
</ol>
<h1><a id="%E4%B8%89%E3%80%81kvc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、 KVC</h1>
<ol>
<li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以----通过一个key来访问某个属性</li>
<li>常见的API有：</li>
</ol>
<ul>
<li>(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</li>
<li>(void)setValue:(id)value forKey:(NSString *)key;</li>
<li>(id)valueForKeyPath:(NSString *)keyPath;</li>
<li>(id)valueForKey:(NSString *)key;</li>
</ul>
<ol start="3">
<li>setValue—会触发kvo,按照setKey:、_setKey查找，没有找到的话，继续查找accessInstanceVariablesDirectly，_key、_isKey、key、isKey查找成员变量，若没查到，报异常。
getValue— 按照getKey:、key、isKey、_key查找，没有找到的话，继续查找accessInstanceVariablesDirectly，_key、_isKey、key、isKey查找成员变量，若没查到，报异常。</li>
</ol>
<h1><a id="%E5%9B%9B%E3%80%81category" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、 Category</h1>
<ol>
<li>Category类方法均被存储在同一个类中，元类方法也被存储在自己的元类方法中。Category底层结构是struct category_t,里面有分类的对象方法、类方法、属性、协议信息。</li>
<li>分类是运行时，会把数据合并到类信息中
类扩展是编译时数据已包含在类中（把.h中的文件放到.m中）</li>
<li>+load
+load会在runtime加载类、分类时调用，在程序运行过程中只调用一次
+load的调用顺序：先调用类再调用分类，调用的先后顺序按照编译的先后顺序（先编译，后调用）, 调用子类的+load之前会先调用父类的+load</li>
<li>Initialize
initialize会在类第一次接受消息后调用，initialize是通过objc_msgSend进行调用，如果子类没有实现initialize，会调用父类（父类可能被调用多次）
(先初始化父类，再初始化子类，每个类只会初始化1次)
如果分类实现了+initialize，就覆盖本身的+initialize调用。
一般先调用父类，再调用子类。</li>
<li>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现,  关联对象提供了以下API:
添加关联对象
void objc_setAssociatedObject(id object, const void * key,
id value, objc_AssociationPolicy policy)
获得关联对象
id objc_getAssociatedObject(id object, const void * key)
移除所有的关联对象
void objc_removeAssociatedObjects(id object)</li>
<li>关联对象原理
关联对象可以理解为间接的添加成员变量
设置关联对象：void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)
关联对象主要有AssociationsManager、AssociationsHashMap（object）、AssociationsMap（key）、ObjectAssociation(uintptr_t _policy、id _value)
<figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1plhnzlxgj30n20ckac4.jpg" alt="" /></figure></li>
</ol>
<h1><a id="%E4%BA%94%E3%80%81block" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、 Block</h1>
<ol>
<li>block是oc对象，有isa指针。_ <em>NSGlobalBlock</em> _ : _ _NSGlobalBlock : NSBlock : NSobject
block是封装了函数调用以及函数调用环境的OC对象</li>
<li>内存分配形式：
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1pli0hnc5j30a406e0sv.jpg" alt="" /></figure></li>
</ol>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1pliejayzj30is04g3z6.jpg" alt="" /></figure></p>
<ol start="3">
<li>
<p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况</p>
<ul>
<li>
<p>block作为函数返回值时</p>
</li>
<li>
<p>将block赋值给__strong指针时</p>
</li>
<li>
<p>block作为Cocoa API中方法名含有usingBlock的方法参数时</p>
</li>
<li>
<p>block作为GCD API的方法参数时</p>
</li>
<li>
<p>ARC下block属性的建议写法</p>
<pre><code class="language-plain_text">@property (strong, nonatomic) void (^block)(void);
@property (copy, nonatomic) void (^block)(void);
</code></pre>
<ul>
<li>MRC下block属性的建议写法</li>
</ul>
<p><code>@property (copy, nonatomic) void (^block)(void);</code></p>
</li>
</ul>
</li>
<li>
<p>当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用
如果block被拷贝到堆上
会调用block内部的copy函数  copy函数内部会调用_Block_object_assign函数
_Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</p>
</li>
</ol>
<p>如果block从堆上移除
会调用block内部的dispose函数  dispose函数内部会调用_Block_object_dispose函数
_Block_object_dispose函数会自动释放引用的auto变量（release）
5.  __block修饰符</p>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1pliu119rj30kq09wmyf.jpg" alt="" /></figure></p>
<ol start="6">
<li>循环引用：对象引用block, block 又引用对象。
解决循环引用问题：用__weak、__unsafe_unretained解决
用__block解决（必须要调用block）</li>
</ol>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1pljgas1tj309c02c74a.jpg" alt="" /></figure>
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1pljk0e85j309802c0sq.jpg" alt="" /></figure>
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1pljo4z02j309c02mq30.jpg" alt="" /></figure>
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1pljrw723j308402mq2t.jpg" alt="" /></figure></p>
<p>六、 Runtime</p>
<ol>
<li>oc的消息机制
OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
objc_msgSend底层有3大阶段：消息发送（当前类、父类中查找）、动态方法解析、消息转发</li>
<li>Runtime
OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行
OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数
平时编写的OC代码，底层都是转换成了Runtime API进行调用</li>
<li>Runtime具体应用
利用关联对象（AssociatedObject）给分类添加属性
遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）
交换方法实现（交换系统的方法）
利用消息转发机制解决方法找不到的异常问题</li>
<li>isa指针
要想学习Runtime，首先要了解它底层的一些常用数据结构，比如isa指针
在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址
从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</li>
</ol>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1plkymo21j309a07mdg9.jpg" alt="" /></figure></p>
<p>Nonpointer：0，代表普通的指针，存储着Class、Meta-Class对象的内存地址，1，代表优化过，使用位域存储更多的信息
has_assoc：是否有设置过关联对象，如果没有，释放时会更快
has_cxx_dtor：是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快
shiftcls：存储着Class、Meta-Class对象的内存地址信息
magic：用于在调试时分辨对象是否未完成初始化
weakly_referenced：是否有被弱引用指向过，如果没有，释放时会更快
deallocating：对象是否正在释放
extra_rc：里面存储的值是引用计数器减1
has_sidetable_rc：引用计数器是否过大无法存储在isa中，如果为1，那么引用计数会存储在一个叫SideTable的类的属性中
5． 消息发送</p>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1pllnz478j30n20aign7.jpg" alt="" /></figure></p>
<ol start="6">
<li>动态方法解析</li>
</ol>
<p><figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1pllu817jj30n209u3zm.jpg" alt="" /></figure></p>
<p>7．消息转发</p>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1plm6xjxcj30n20ae75n.jpg" alt="" /></figure></p>
<p>七、 RunLoop</p>
<ol>
<li>运行循环:在程序运行过程中循环做一些事情
应用范畴:定时器（Timer）、PerformSelector；GCD Async Main Queue；事件响应、手势识别、界面刷新；网络请求；AutoreleasePool</li>
<li>RunLoop的基本作用</li>
</ol>
<p><figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1plmlvm81j30oo07wmyd.jpg" alt="" /></figure></p>
<ol start="3">
<li>RunLoop与线程
每条线程都有唯一的一个与之对应的RunLoop对象
RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value
线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建
RunLoop会在线程结束时销毁
主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
<li>RunLoop相关的类</li>
</ol>
<p><figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1plmxf2m4j30n20ag765.jpg" alt="" /></figure></p>
<p>CFRunLoopModeRef代表RunLoop的运行模式
一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer
RunLoop启动时只能选择其中一个Mode，作为currentMode
如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入
不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响
如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出
常见的2种Mode：
kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行
UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响
5. 添加Observer监听RunLoop的所有状态
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1pln4lkk5j30n2096myf.jpg" alt="" /></figure>
6. RunLoop的运行逻辑
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1plne9o4uj30n20b0jtn.jpg" alt="" /></figure>
八、 多线程</p>
<ol>
<li>常见的多线程
<figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1plnmf2nkj30n20butaj.jpg" alt="" /></figure></li>
<li>GCD中有2个用来执行任务的函数
用同步的方式执行任务：dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
queue：队列   block：任务
用异步的方式执行任务：dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
GCD的队列可以分为2大类型
并发队列（Concurrent Dispatch Queue）：可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）  并发功能只有在异步（dispatch_async）函数下才有效
串行队列（Serial Dispatch Queue）让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）
同步和异步主要影响：能不能开启新的线程
同步：在当前线程中执行任务，不具备开启新线程的能力
异步：在新的线程中执行任务，具备开启新线程的能力
并发和串行主要影响：任务的执行方式
并发：多个任务并发（同时）执行
串行：一个任务执行完毕后，再执行下一个任务
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1plo2dlvtj30gm052wf7.jpg" alt="" /></figure></li>
</ol>
<p>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）
3. 加锁的类型
OSSpinLock、os_unfair_lock、pthread_mutex、dispatch_semaphore、dispatch_queue(DISPATCH_QUEUE_SERIAL)、NSLock、NSRecursiveLock、NSCondition、NSConditionLock、@synchronized</p>
<ol>
<li>
<p>OSSpinLock
OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源
目前已经不再安全，可能会出现优先级反转问题
如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁
需要导入头文件#import &lt;libkern/OSAtomic.h&gt;
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1plof35gkj30n204wgmc.jpg" alt="" /></figure></p>
</li>
<li>
<p>os_unfair_lock
os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持
从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等
需要导入头文件#import &lt;os/lock.h&gt;
<figure><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1plokx2fbj30ee03sglx.jpg" alt="" /></figure></p>
</li>
<li>
<p>pthread_mutex
mutex叫做”互斥锁”，等待锁的线程会处于休眠状态 需要导入头文件#import &lt;pthread.h&gt;
<figure><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1qcly4gfzj30f407qq3v.jpg" alt="" /></figure>
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1qcm5n3p2j30n203et97.jpg" alt="" /></figure>
pthread_mutex ? 条件
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1qcmm4gg5j30gi0b075w.jpg" alt="" /></figure></p>
</li>
<li>
<p>NSLock、NSRecursiveLock
NSLock是对mutex普通锁的封装
<figure><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1qcmxn5mbj30n204wwf7.jpg" alt="" /></figure>
NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致</p>
</li>
<li>
<p>NSCondition
NSCondition是对mutex和cond的封装
<figure><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1qcn1aelvj30n203474q.jpg" alt="" /></figure></p>
</li>
<li>
<p>NSConditionLock
NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</p>
</li>
<li>
<p>dispatch_semaphore
semaphore叫做”信号量”
信号量的初始值，可以用来控制线程并发访问的最大数量
信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p>
</li>
</ol>
<p>8&gt;.@synchronized
@synchronized是对mutex递归锁的封装
源码查看：objc4中的objc-sync.mm文件
@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
<ol start="4">
<li>自旋锁、互斥锁比较</li>
</ol>
<p>什么情况使用自旋锁比较划算？
预计线程等待锁的时间很短
加锁的代码（临界区）经常被调用，但竞争情况很少发生
CPU资源不紧张
多核处理器
什么情况使用互斥锁比较划算？
预计线程等待锁的时间较长
单核处理器
临界区有IO操作
临界区代码复杂或者循环量大
临界区竞争非常激烈</p>
<ol start="5">
<li>
<p>atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁
可以参考源码objc4的objc-accessors.mm
它并不能保证使用属性的过程是线程安全的
九、 内存管理</p>
</li>
<li>
<p>CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用，解决方案：使用block</p>
</li>
<li>
<p>NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时
而GCD的定时器会更加准时</p>
</li>
<li>
<p>Tagged Pointer
从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储
在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值
使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中
当指针不够存储数据时，才会使用动态分配内存的方式来存储数据
objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销
如何判断一个指针是否为Tagged Pointer？
iOS平台，最高有效位是1（第64bit）  Mac平台，最低有效位是1</p>
</li>
<li>
<p>oc对象内存管理
在iOS中，使用引用计数来管理OC对象的内存
一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间
调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1
内存管理的经验总结
当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它
想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1
可以通过以下私有函数来查看自动释放池的情况
extern void _objc_autoreleasePoolPrint(void);</p>
</li>
<li>
<p>copy和mutableCopy</p>
</li>
</ol>
<p>6． 自动释放池
自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage
调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的
每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址
所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起
AutoreleasePoolPage的结构
调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址
调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY
id *next指向了下一个能存放autorelease对象地址的区域<br />
7.  Runloop和Autorelease
iOS在主线程的Runloop中注册了2个Observer
第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()
第2个Observer
监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()
监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()
十、 性能优化</p>
<ol>
<li>在屏幕成像的过程中，CPU和GPU起着至关重要的作用
CPU（Central Processing Unit，中央处理器）：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）
GPU（Graphics Processing Unit，图形处理器）：纹理的渲染
在iOS中是双缓冲机制，有前帧缓存、后帧缓存</li>
<li>卡顿产生：当GPU和CPU的时间总和大于垂直信号来的过程
卡顿解决的主要思路
尽可能减少CPU、GPU资源消耗
按照60FPS的刷帧率，每隔16ms就会有一次VSync信号</li>
<li>卡顿优化 ? CPU
尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView
不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
Autolayout会比直接设置frame消耗更多的CPU资源
图片的size最好刚好跟UIImageView的size保持一致
控制一下线程的最大并发数量
尽量把耗时的操作放到子线程
文本处理（尺寸计算、绘制）
图片处理（解码、绘制）
卡顿优化 ? GPU
尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
尽量减少视图数量和层次
减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES
尽量避免出现离屏渲染</li>
<li>离屏渲染
在OpenGL中，GPU有2种渲染方式
On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
离屏渲染消耗性能的原因
需要创建新的缓冲区
离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕
哪些操作会触发离屏渲染？
光栅化，layer.shouldRasterize = YES
遮罩，layer.mask
圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0
考虑通过CoreGraphics绘制裁剪圆角，或者叫美工提供圆角图片
阴影，layer.shadowXXX
如果设置了layer.shadowPath就不会产生离屏渲染
5．耗电
来源：CPU处理，Processing、网络，Networking、定位，Location、图像，Graphics
优化：尽可能降低CPU、GPU功耗；少用定时器
优化I/O操作
尽量不要频繁写入小数据，最好批量一次性写入
读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问
数据量比较大的，建议使用数据库（比如SQLite、CoreData）
网络优化
减少、压缩网络数据，如果多次请求的结果是相同的，尽量使用缓存
使用断点续传，否则网络不稳定时可能多次传输相同的内容
网络不可用时，不要尝试执行网络请求
让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间
批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载
定位优化
如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电
如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务
尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest
需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新
尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion:
硬件检测优化
用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
<li>启动APP时，runtime所做的事情有
调用map_images进行可执行文件内容的解析和处理
在load_images中调用call_load_methods，调用所有Class和Category的+load方法
进行各种objc结构的初始化（注册Objc类牎⒊跏蓟喽韵蟮鹊龋
调用C++静态初始化器和__attribute__((constructor))修饰的函数
到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，)都已经按格式成功加载到内存中，被runtime 所管理</li>
<li>启动APP时，main
APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库
并由runtime负责加载成objc定义的结构
所有初始化工作结束后，dyld就会调用main函数
接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法</li>
<li>APP的启动优化
按照不同的阶段
Dyld：减少动态库、合并一些动态库（定期清理不必要的动态库）
减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）
减少C++虚函数数量
Swift尽量使用struct
Runtime：用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load
Main：在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中
按需加载</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS相册相关知识]]></title>
    <link href="http://kaelinda.top/16336626270388.html"/>
    
    <updated>2021-10-08T11:10:27+08:00</updated>
    <id>http://kaelinda.top/16336626270388.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="alassetlibrary" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ALAssetLibrary</h2>
<p><a href="https://www.cnblogs.com/yang-shuai/p/5909777.html">ALAssetLibrary 使用详解</a></p>
<p><a href="https://www.jianshu.com/p/ac3d7f490f82">Photo Frameworks之PHAssetCollection、PHCollectionList和PHAsset</a></p>
<p><a href="https://www.jianshu.com/p/c8f42a367893">iOS 8+（PhotoKit） 获取相册资源工具(扩展性较强)</a></p>
<p><a href="http://kayosite.com/ios-development-and-detail-of-photo-framework.html">iOS 开发之照片框架详解</a></p>
<p><a href="http://kayosite.com/ios-development-and-detail-of-photo-framework-part-two.html">iOS 开发之照片框架详解之二 —— PhotoKit 详解 上</a></p>
<p>[ iOS 开发之照片框架详解之二 —— PhotoKit 详解 下] (<a href="http://kayosite.com/ios-development-and-detail-of-photo-framework-part-three.html">http://kayosite.com/ios-development-and-detail-of-photo-framework-part-three.html</a>)</p>
<p><a href="https://www.cnblogs.com/jackma86/p/5130884.html">iOS9中将图片保存到照片中的某个相册的方法说明</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2019 iOS面试题收纳]]></title>
    <link href="http://kaelinda.top/16336626146062.html"/>
    
    <updated>2021-10-08T11:10:14+08:00</updated>
    <id>http://kaelinda.top/16336626146062.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="c%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C基础</h2>
<h2><a id="oc%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OC基础</h2>
<ul>
<li><a href="https://www.jianshu.com/p/de0d30047e82">UIResponder究竟是个什么东西</a></li>
<li><a href="https://www.jianshu.com/p/6425307380f9">对iOS响应链和事件传递的总结</a></li>
</ul>
<h3><a id="category%E3%80%81protocol%E3%80%81extention" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Category、Protocol、Extention</h3>
<ul>
<li><a href="https://tech.meituan.com/2015/03/03/diveintocategory.html">深入理解Objective-C：Category</a></li>
<li><a href="https://www.jianshu.com/p/a4af101f6cec">Category 和 Extention 的本质区别</a></li>
</ul>
<h3><a id="%E5%A4%9A%E7%BA%BF%E7%A8%8Bgcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多线程 &amp;&amp; GCD</h3>
<ul>
<li><a href="https://www.cnblogs.com/ioshe/p/5937933.html">iOS多线程GCD详解</a></li>
<li><a href="https://www.jianshu.com/p/31b810b7986b">OC 多线程之 GCD知识从基础到进阶 </a></li>
</ul>
<h3><a id="runtime" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>runtime</h3>
<ul>
<li><a href="">runtime 详解</a></li>
<li><a href="https://www.jianshu.com/p/291754a90d2b">深入浅出Runtime 一 概念</a></li>
<li><a href="https://www.jianshu.com/p/28c742fb8bb3">深入浅出Runtime (二) Runtime的消息机制</a></li>
<li><a href="https://www.jianshu.com/p/2b61270cd038">深入浅出Runtime (三) Runtime的消息转发</a></li>
<li><a href="https://www.jianshu.com/p/ecdb5fa307f8">深入浅出Runtime (四) Runtime的实际应用之一，字典转模型</a></li>
<li><a href="https://www.jianshu.com/p/9263720cbd91">消息转发详解</a></li>
</ul>
<h3><a id="runloop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>runloop</h3>
<ul>
<li><a href="https://www.cnblogs.com/ioshe/p/5489112.html">RunLoop详解</a></li>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
<li><a href="https://segmentfault.com/a/1190000004938638">Runloop知识树</a></li>
</ul>
<h3><a id="%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据加密</h3>
<ul>
<li><a href="https://www.jianshu.com/p/70d81a05446b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">iOS中常见的几种加密方式总结！</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【进阶】iOS自定义ViewController转场动画]]></title>
    <link href="http://kaelinda.top/16336625900086.html"/>
    
    <updated>2021-10-08T11:09:50+08:00</updated>
    <id>http://kaelinda.top/16336625900086.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E9%81%B5%E5%AE%88%E5%8D%8F%E8%AE%AEuiviewcontrolleranimatedtransitioning%E7%9A%84%E5%8A%A8%E7%94%BB%E8%BD%AC%E5%9C%BA%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>遵守协议 <code>&lt;UIViewControllerAnimatedTransitioning&gt;</code>的动画转场管理对象</h2>
<ul>
<li>API</li>
</ul>
<pre><code class="language-plain_text">// 自定义动画时长
- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext{
    return 0.4;
}
// 自定义动画过程
- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext{
}
</code></pre>
<ul>
<li>实现</li>
</ul>
<pre><code class="language-plain_text">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{
    return 0.3;
}
//所有的过渡动画事务都在这个方法里面完成
- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{

 //取出转场前后的视图控制器
  UIViewController * fromVC = (UIViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
  UIViewController * toVC = (UIViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];

 //取出转场前后视图控制器上的视图view
    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];
    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];

 //这里有个重要的概念containerView，要做转场动画的视图就必须要加入containerView上才能进行，可以理解containerView管理着所有做转场动画的视图
    UIView *containerView = [transitionContext containerView];

  //如果加入了手势交互转场，就需要根据手势交互动作是否完成/取消来做操作，完成标记YES，取消标记NO，必须标记，否则系统认为还处于动画过程中，会出现无法交互之类的bug
   [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
     if ([transitionContext transitionWasCancelled]) { 
    //如果取消转场
          }else{
   //完成转场
     }
}
</code></pre>
<h2><a id="%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BBuipercentdriveninteractivetransition%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承父类<code>UIPercentDrivenInteractiveTransition</code>的交互动画管理对象</h2>
<ul>
<li>API</li>
</ul>
<pre><code class="language-plain_text">//必要调用实现的系统方法
//手势过程中，通过updateInteractiveTransition设置转场过程动画进行的百分比，然后系统会根据百分比自动布局动画控件，不用我们控制了
 [self updateInteractiveTransition:percentComplete];
//完成转场操作
 [self finishInteractiveTransition];
//取消转场操作
 [self cancelInteractiveTransition];
</code></pre>
<h2><a id="%E9%81%B5%E5%AE%88uiviewcontrollertransitioningdelegate%E7%9A%84%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>遵守<code>&lt;UIViewControllerTransitioningDelegate&gt;</code>的视图控制器转场动画管理对象</h2>
<pre><code class="language-plain_text">-(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{
    return self.pushAnimator;
}

-(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed{
    return self.popAnimator;
}

#pragma mark ------- 手势交互添加

- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator{
    
    return nil;//返回继承父类`UIPercentDrivenInteractiveTransition`的交互动画管理对象
}

- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator{
        return nil;//返回继承父类`UIPercentDrivenInteractiveTransition`的交互动画管理对象
}
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用步骤</h2>
<ul>
<li>
<p>设置代理</p>
<ul>
<li>
<p>push</p>
<p><code>self.navigationController.delegate = self.animatedTransition;</code></p>
</li>
<li>
<p>present</p>
<p><code>toViewController.transitioningDelegate = self.browserAnimation;</code></p>
</li>
</ul>
</li>
<li>
<p>分别设置 push POP 是哪个动画对象</p>
<pre><code class="language-plain_text">-(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{
    return self.pushAnimator;
}
-(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed{
    return self.popAnimator;
}
- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator{
    
    return nil;
}

- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator{
        return nil;
}
 
// ---------- push 还可以这么去分配动画对象
-(id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC{

if (operation == UINavigationControllerOperationPush) {
    return self.pushAniamtor;
    
}else if (operation == UINavigationControllerOperationPop){
    return self.popAnimator;
}
return nil;
</code></pre>
</li>
</ul>
<p>}
```</p>
<ul>
<li>
<p>动画对象内 设置 动画时长 和 动画实现</p>
<pre><code class="language-plain_text">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext{
return 0.4;
</code></pre>
</li>
</ul>
<p>}</p>
<ul>
<li>(void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext{
}
<pre><code class="language-plain_text">




</code></pre>
</li>
</ul>
<h2><a id="%E5%9D%91%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>坑点</h2>
<ul>
<li>
<pre><code class="language-plain_text">`.modalPresentationStyle = UIModalPresentationCustom;`modalPresentationStyle这个属性会影响present出来的VC的横竖屏（横屏变竖屏）
</code></pre>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charlse使用进阶]]></title>
    <link href="http://kaelinda.top/16336625721322.html"/>
    
    <updated>2021-10-08T11:09:32+08:00</updated>
    <id>http://kaelinda.top/16336625721322.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="https%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTPS数据抓包</h2>
<h3><a id="%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E7%AB%AF%E5%8F%A3%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置代理 + 端口号</h3>
<blockquote>
<p>这一步的目的就是将安装了charlse的电脑作为网络请求的代理服务器
1、让电脑代替手机去向服务器发送请求
2、让电脑代替server服务器向手机返回指定的数据</p>
</blockquote>
<ul>
<li><strong>查看本地作为代理电脑的IP地址 以及 开放端口号</strong></li>
</ul>
<p><figure><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3adjwhexsj30k80ceqdy.jpg" alt="查看端口号" /><figcaption>查看端口号<figcaption></figure></p>
<p>然后就会弹出信息框
<figure><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3adp0wu3qj30qw0g8aay.jpg" alt="IP信息框" /><figcaption>IP信息框<figcaption></figure></p>
<ul>
<li>
<p><strong>更改端口号【有两种入口】</strong></p>
<ul>
<li>
<p>更改端口号方式1
<figure><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3admaiajgj30ug0jqqjo.jpg" alt="更改端口号方式1" /><figcaption>更改端口号方式1<figcaption></figure></p>
</li>
<li>
<p>更改端口号方式2
<figure><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3adna45g8j311609ydll.jpg" alt="更改端口号方式2" /><figcaption>更改端口号方式2<figcaption></figure></p>
</li>
</ul>
</li>
</ul>
<h3><a id="%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手机连接代理</h3>
<p>设置 -- &gt; 无线网络 --&gt; 连接并点击与代理电脑同一局域网的网络 --&gt; 配置代理  --&gt; 手动
<strong>设置服务器和端口</strong>
【不需要开启鉴定】
存储一下！！！！！！！！😂这一步很关键哦</p>
<p><figure><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3adv4cz00j30om17uare.jpg" alt="手机端设置代理" /><figcaption>手机端设置代理<figcaption></figure></p>
<h3><a id="%E4%BB%A3%E7%90%86%E7%94%B5%E8%84%91%E5%85%81%E8%AE%B8%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%BF%9E%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代理电脑允许手机端连接</h3>
<p>操作完上一步，这时候代理电脑charlse会弹出一个是否允许连接代理的alert 点击 <strong>allow</strong> 【这一步也很关键】</p>
<hr />
<p>到此为止你就可以抓取手机上发出的 所有 请求了。
但是你会发现，为什么所有的https请求都是加密的信息  都是乱码，客观莫急，请往下看！👀</p>
<hr />
<h3><a id="%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装证书 + 信任证书</h3>
<p>charlse的 help --&gt; SSL Proxying --&gt; Install * Mobile Device or Remote Vrowser
<strong>手机在连接代理的状态下</strong>
Safari浏览器下，地址栏输入 <code>chls.pro/ssl</code></p>
<ul>
<li>安装证书
设置 --&gt; 通用 --&gt; 描述文件
点击</li>
<li>信任证书
设置 --&gt; 通用 --&gt; 证书信任设置</li>
</ul>
<p><figure><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3ae23oq3fj31d80j0nol.jpg" alt="charlse证书信息" /><figcaption>charlse证书信息<figcaption></figure></p>
<p><figure><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3ae3etebyj317a08y40b.jpg" alt="局域网证书下载地址" /><figcaption>局域网证书下载地址<figcaption></figure></p>
<p><figure><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3aehcl6zfj30ou17r1fc.jpg" alt="" /></figure></p>
<h3><a id="%E9%85%8D%E7%BD%AE%E6%8A%93%E5%8C%85%E5%9F%9F%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置抓包域名</h3>
<p>Proxy --&gt; SSL Proxying Setting --&gt; Enable SSL Proxying --&gt; add --&gt; OK👌</p>
<p><figure><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3aeoo5tvxj30hm0k07jh.jpg" alt="" /></figure></p>
<p><figure><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3aepurqtbj30ww0ok0vp.jpg" alt="" /></figure></p>
<p><figure><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3aeqmhdmsj30og0agabf.jpg" alt="" /></figure></p>
<p>--</p>
<p>这个时候你就可以尽情的享受抓取别人数据的爽快了~就像是有了透视眼😂
如果还是抓不到数据 ，那就重启下Charlse 。毕竟重启能解决大多数棘手的问题。
如果还是抓不到你想要抓取的数据...那就是别人是秘闻传输的信息加密手段比较强悍了</p>
<p>--</p>
<h2><a id="%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%81%87%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置本地假数据</h2>
<p>当Server接口跟不上，你是否还在为创建各式各样的假数据而烦恼？你的代码里面是否会有很多Test方法？往下看，你会感谢我的。</p>
<p><figure><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3af1lo4e8j30d40pstoc.jpg" alt="" /></figure></p>
<p><figure><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3af3mrgjrj30u00io0vm.jpg" alt="" /></figure></p>
<p><figure><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3afabqmpkj30q80ngtb3.jpg" alt="" /></figure></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIVisualEffectView iOS8以后的毛玻璃效果实现]]></title>
    <link href="http://kaelinda.top/16336625003411.html"/>
    
    <updated>2021-10-08T11:08:20+08:00</updated>
    <id>http://kaelinda.top/16336625003411.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%85%88%E7%9C%8B%E4%B8%80%E4%B8%8B%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>先看一下简单的使用</h2>
<pre><code class="language-plain_text">
// 创建一个特效对象
UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];

// 创建一个毛玻璃视图
UIVisualEffectView *blurView = [[UIVisualEffectView alloc] initWithEffect:blurEffect];
blurView.clipsToBounds = YES;
blurView.layer.borderColor = [[UIColor blackColor] colorWithAlphaComponent:0.4f].CGColor;
blurView.layer.borderWidth = 1.0;
blurView.layer.cornerRadius = 6.0;

// label
UILabel *label = [[UILabel alloc] init];
label.textColor = [UIColor colorWithWhite:0.4f alpha:1.0f];

// add the label to effect view
[blurView.contentView addSubview:label];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Viewcontroller顶部白条]]></title>
    <link href="http://kaelinda.top/16336624814848.html"/>
    
    <updated>2021-10-08T11:08:01+08:00</updated>
    <id>http://kaelinda.top/16336624814848.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E9%A1%B6%E9%83%A8%E7%99%BD%E6%9D%A120pt%E5%B7%A6%E5%8F%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顶部白条 20pt左右</h2>
<pre><code class="language-plain_text">self.automaticallyAdjustsScrollViewInsets = NO;
self.edgesForExtendedLayout = UIRectEdgeNone;
if (@available(iOS 11.0, *)) {
    UIScrollView.appearance.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 之 APP安全]]></title>
    <link href="http://kaelinda.top/16336624630931.html"/>
    
    <updated>2021-10-08T11:07:43+08:00</updated>
    <id>http://kaelinda.top/16336624630931.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E8%B6%8A%E7%8B%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>检测设备是否越狱</h2>
<pre><code class="language-plain_text">+ (BOOL)isJailBreak {
	if ([[NSFileManager defaultManager] fileExistsAtPath:@&quot;/Applications/Cydia.app&quot;]){
		return YES;
	}
	
	if ([[NSFileManager defaultManager] fileExistsAtPath:@&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;]){
		return YES;
	}
	
	if ([[NSFileManager defaultManager] fileExistsAtPath:@&quot;/bin/bash&quot;]){
		return YES;
	}
	
	if ([[NSFileManager defaultManager] fileExistsAtPath:@&quot;/usr/sbin/sshd&quot;]){
		return YES;
	}
	
	if ([[NSFileManager defaultManager] fileExistsAtPath:@&quot;/etc/apt&quot;]){
		return YES;
	}
	if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;cydia://&quot;]]) {
		return YES;
	}
	return NO;
}
</code></pre>
<h2><a id="%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>检测设备网络环境是否开启代理</h2>
<pre><code class="language-plain_text">NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings());
NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef _Nonnull)([NSURL URLWithString:@&quot;https://www.baidu.com&quot;]), (__bridge CFDictionaryRef _Nonnull)(proxySettings)));

NSLog(@&quot;\n%@&quot;,proxies);
NSDictionary *settings = proxies[0];
NSLog(@&quot;%@&quot;,[settings objectForKey:(NSString *)kCFProxyHostNameKey]);
NSLog(@&quot;%@&quot;,[settings objectForKey:(NSString *)kCFProxyPortNumberKey]);
NSLog(@&quot;%@&quot;,[settings objectForKey:(NSString *)kCFProxyTypeKey]);
    if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@&quot;kCFProxyTypeNone&quot;])
    {
        NSLog(@&quot;kael 没代理&quot;);
    }
                                                                                                     else
    {
        NSLog(@&quot;kael 设置了代理&quot;);
    }
</code></pre>
<h2><a id="app%E7%A6%81%E6%AD%A2%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>APP 禁止动态调试</h2>
<pre><code class="language-plain_text">#import &lt;UIKit/UIKit.h&gt; 
#import &quot;AppDelegate.h&quot;  
#import &lt;dlfcn.h&gt;

typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);
#if !defined(PT_DENY_ATTACH)
#define PT_DENY_ATTACH 31
#endif  // !defined(PT_DENY_ATTACH)

void disable_gdb() {
  void* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);
  ptrace_ptr_t ptrace_ptr = dlsym(handle, &quot;ptrace&quot;);
  ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);
  dlclose(handle);
}

int main(int argc, char * argv[]) {
#ifndef DEBUG
    disable_gdb();
#endif
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>
<p>如果你在Xcode调试环境下，去掉#ifndef DEBUG #endif这句话，你会发现，Xcode无法调试该应用；因为动态的加载了ptrace，然后给传输的宏是PT_DENY_ATTACH 拒绝附加进程</p>
<h2><a id="%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码混淆 脚本</h2>
<p><a href="https://zfj1128.blog.csdn.net/article/details/95482006">代码混淆相关 参考文章</a></p>
<pre><code class="language-plain_text">TABLENAME=symbols
SYMBOL_DB_FILE=&quot;$PROJECT_DIR/CodeObfuscation/symbols&quot;
STRING_SYMBOL_FILE=&quot;$PROJECT_DIR/CodeObfuscation/func.list&quot;
HEAD_FILE=&quot;$PROJECT_DIR/CodeObfuscation/codeObfuscation.h&quot;
export LC_CTYPE=C

#维护数据库方便日后作排重
createTable()
{
echo &quot;create table $TABLENAME(src text, des text);&quot; | sqlite3 $SYMBOL_DB_FILE
}

insertValue()
{
echo &quot;insert into $TABLENAME values('$1' ,'$2');&quot; | sqlite3 $SYMBOL_DB_FILE
}

query()
{
echo &quot;select * from $TABLENAME where src='$1';&quot; | sqlite3 $SYMBOL_DB_FILE
}

ramdomString()
{
openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16
}

rm -f $SYMBOL_DB_FILE
rm -f $HEAD_FILE
createTable

touch $HEAD_FILE
echo '#ifndef Demo_codeObfuscation_h
#define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILE
echo &quot;//confuse string at `date`&quot; &gt;&gt; $HEAD_FILE
cat &quot;$STRING_SYMBOL_FILE&quot; | while read -ra line; do
if [[ ! -z &quot;$line&quot; ]]; then
ramdom=`ramdomString`
echo $line $ramdom
insertValue $line $ramdom
echo &quot;#define $line $ramdom&quot; &gt;&gt; $HEAD_FILE
fi
done
echo &quot;#endif&quot; &gt;&gt; $HEAD_FILE


sqlite3 $SYMBOL_DB_FILE .dump
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 图表工具]]></title>
    <link href="http://kaelinda.top/16336623484572.html"/>
    
    <updated>2021-10-08T11:05:48+08:00</updated>
    <id>http://kaelinda.top/16336623484572.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="ios-echarts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iOS-Echarts</h2>
<p><a href="https://www.jianshu.com/p/3d5fe1f4693d">iOS-Echarts 参考文章</a></p>
<ul>
<li>基于js，让WebView加载、渲染UI</li>
</ul>
<h2><a id="ios-charts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ios-charts</h2>
<p>MPAndroidChart 在iOS系统上面的移植</p>
<ul>
<li>用的swift编写，需要在现有OC项目中创建桥接文件 比较笨重</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/article/1336386">ios-charts使用参考文章</a></p>
<p><a href="https://www.jianshu.com/p/94cdcc08d1ae">安卓iOS 通用教程</a></p>
<h2><a id="github%E4%B8%8A%E4%BC%98%E7%A7%80%E7%9A%84oc%E5%9B%BE%E6%A0%87%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GitHub上优秀的OC图标库</h2>
<p><a href="https://github.com/search?l=Objective-C&amp;o=desc&amp;q=chart&amp;s=stars&amp;type=Repositories">GitHub上优秀的OC图标库</a></p>
<p><a href="https://github.com/search?l=Java&amp;o=desc&amp;q=chart&amp;s=stars&amp;type=Repositories">GitHub上优秀的java图标库</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS13适配注意事项]]></title>
    <link href="http://kaelinda.top/16336623112375.html"/>
    
    <updated>2021-10-08T11:05:11+08:00</updated>
    <id>http://kaelinda.top/16336623112375.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<p>技术参考：</p>
<p><a href="https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/">apple login</a></p>
<p><a href="https://www.jianshu.com/p/46cd57b98b0d">IOS13适配-详细</a></p>
<p><a href="https://www.jianshu.com/p/373a8fb3b345">iOS 13 适配(持续更新中)</a></p>
<p><a href="https://www.jianshu.com/p/4654f8f6e16e">iOS13适配</a></p>
<p><a href="https://juejin.im/post/5d745f8af265da03b5746fa0">掘金 iOS 13适配01</a></p>
<p><a href="https://juejin.im/post/5d00af64e51d455d88219ee2#heading-8">掘金  适配 iOS13</a></p>
<p><a href="https://github.com/ChenYilong/iOS13AdaptationTips/issues?q=is%3Aissue+is%3Aopen+label%3Anote">iOS 13 更新tips</a></p>
<p><a href="https://medium.com/@hacknicity/view-controller-presentation-changes-in-ios-13-ac8c901ebc4e">View Controller Presentation Changes in iOS 13</a></p>
<h2><a id="1-apple-login%EF%BC%88-2020%E5%B9%B44%E6%9C%88%E4%BB%BD%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Apple Login （2020年4月份）</h2>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs-assets.developer.apple.com%2Fpublished%2F80ac09c84c%2FAddingTheSignInWithAppleFlowToYourApp.zip">附上官方Demo：下载地址</a></p>
<h2><a id="2-dark-mode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Dark Mode</h2>
<h3><a id="2-1%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E5%88%87%E6%8D%A2%E7%9B%91%E5%90%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1 暗黑模式 状态判断 &amp;&amp; 切换监听</h3>
<ul>
<li>判断模式状态</li>
</ul>
<pre><code class="language-plain_text">if (UITraitCollection.currentTraitCollection.userInterfaceStyle == UIUserInterfaceStyleDark) {
    // 暗黑模式
}
else {
    // 正常模式
}
</code></pre>
<ul>
<li>监听模式切换</li>
</ul>
<pre><code class="language-plain_text">// 注意:参数为变化前的traitCollection
- (void)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection;

// 判断两个UITraitCollection对象是否不同
- (BOOL)hasDifferentColorAppearanceComparedToTraitCollection:(UITraitCollection *)traitCollection;
</code></pre>
<h3><a id="2-2%E7%A6%81%E7%94%A8%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2 禁用暗黑模式</h3>
<ul>
<li>
<p>info.plist 内APP级别禁用暗黑模式</p>
<p>Key: <code>User Interface Style</code>
value: <code>Light</code></p>
</li>
<li>
<p>widow级别的禁用暗黑模式</p>
<pre><code class="language-plain_text">if (@available(iOS 13.0, *)) {
    [UIApplication sharedApplication].keyWindow.overrideUserInterfaceStyle = UIUserInterfaceStyleLight;
}
</code></pre>
</li>
<li>
<p>ViewController级别禁用暗黑模式</p>
<p>想全局禁用需要在 baseVC内全局禁用</p>
<pre><code class="language-plain_text">#if defined(__IPHONE_13_0) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0
- (UIUserInterfaceStyle)overrideUserInterfaceStyle{
    return UIUserInterfaceStyleLight;
}
#endif
</code></pre>
</li>
<li>
<p>view级别禁用暗黑模式</p>
<pre><code class="language-plain_text">view.overrideUserInterfaceStyle = UIUserInterfaceStyleLight;
</code></pre>
</li>
</ul>
<h3><a id="2-3%E9%80%82%E9%85%8D%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F%E9%A2%9C%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.3 适配暗黑模式颜色</h3>
<p><a href="https://www.jianshu.com/p/7925bd51d2d6">参考这里 ：iOS开发如何适配暗黑模式（Dark Mode）</a></p>
<pre><code class="language-plain_text">+ (UIColor *)colorWithDynamicProvider:(UIColor * (^)(UITraitCollection *))dynamicProvider API_AVAILABLE(ios(13.0), tvos(13.0)) API_UNAVAILABLE(watchos);
- (UIColor *)initWithDynamicProvider:(UIColor * (^)(UITraitCollection *))dynamicProvider API_AVAILABLE(ios(13.0), tvos(13.0)) API_UNAVAILABLE(watchos);
</code></pre>
<pre><code class="language-plain_text">[UIColor colorWithDynamicProvider:^UIColor * _Nonnull(UITraitCollection * _Nonnull trait) {
    if (trait.userInterfaceStyle == UIUserInterfaceStyleDark) {
        return UIColorRGB(0x000000);
    } else {
        return UIColorRGB(0xFFFFFF);
    }
 }];
</code></pre>
<h2><a id="3-present%E5%8D%8A%E5%B1%8F%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. present 半屏问题</h2>
<p><code>modalPresentationStyle</code>属性默认不是<code>UIModalPresentationFullScreen</code>了，需要根据需求手动设置。</p>
<pre><code class="language-plain_text">LXNavigationViewController *nav = [[LXNavigationViewController alloc] initWithRootViewController:loginViewController];
nav.modalPresentationStyle = UIModalPresentationFullScreen;
[self presentViewController:nav animated:YES completion:nil];

</code></pre>
<ul>
<li>
<p>全局hook <code>presentViewController</code>方法</p>
<pre><code class="language-plain_text">+ (void)hoookPresentFuc{
    [UIViewController aspect_hookSelector:@selector(presentViewController:animated:completion:) withOptions:AspectPositionBefore usingBlock:^(id&lt;AspectInfo&gt; aspectInfo){
        UIViewController *presentingVC =  (UIViewController *)aspectInfo.arguments.firstObject;
        presentingVC.modalPresentationStyle = UIModalPresentationFullScreen;
    } error:NULL];
}

</code></pre>
</li>
</ul>
<h2><a id="4-uitextfield" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. UITextField</h2>
<ul>
<li>支付输入密码有问题</li>
</ul>
<h3><a id="uitextfield%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7-placeholderlabel%E8%A2%AB%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UITextField 的私有属性 _placeholderLabel 被禁止访问了</h3>
<ul>
<li><code>_placeholderLabel.textColor</code> 私有属性被禁止访问</li>
</ul>
<pre><code class="language-plain_text">[self.textField setValue:self.placeholderColor forKeyPath:@&quot;_placeholderLabel.textColor&quot;];
</code></pre>
<p>崩溃信息：</p>
<pre><code class="language-plain_text">'Access to UITextField's _placeholderLabel ivar is prohibited. 
This is an application bug' 
</code></pre>
<ul>
<li>解决方案</li>
</ul>
<pre><code class="language-plain_text">UITextField有个attributedPlaceholder的属性，我们可以自定义这个富文本来达到我们需要的结果。

NSMutableAttributedString *placeholderString = [[NSMutableAttributedString alloc] initWithString:placeholder attributes:@{NSForegroundColorAttributeName : self.placeholderColor}];
_textField.attributedPlaceholder = placeholderString;
</code></pre>
<ul>
<li>项目适配代码</li>
</ul>
<pre><code class="language-plain_text">if (@available(iOS 13.0, *)) {
    if (textField.attributedText.length &gt; 0) {
        color = textField.attributedText.color;
    }
}else{
    color = [textField valueForKeyPath:@&quot;_placeholderLabel.textColor&quot;];
}
</code></pre>
<p>iOS 13 通过 KVC 方式修改私有属性，有 Crash 风险，谨慎使用！并不是所有KVC都会Crash，要尝试！</p>
<h2><a id="5-uitextview%E5%90%8C%E4%B8%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. UITextView 同上</h2>
<h2><a id="6-navigationbar%E4%BD%BF%E7%94%A8-uinavigation-sxfixspace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. navigationBar 使用<code>UINavigation+SXFixSpace</code></h2>
<pre><code class="language-plain_text">if ([NSStringFromClass(subview.class) containsString:@&quot;ContentView&quot;]) {
    // 结构调整后 在这里return掉
    if (@available(iOS 13.0, *)) {
        if ([NSStringFromClass(subview.class) containsString:@&quot;_UINavigationBarContentView&quot;]) {
            return;
        }
    }

    //可修正iOS11之后的偏移
    subview.layoutMargins = UIEdgeInsetsMake(0, space, 0, space);break;
}
</code></pre>
<p>同时，下面的属性也已经被禁止访问了：</p>
<ul>
<li>
<p><code>[barBgView valueForKey:@&quot;_shadowView&quot;];</code></p>
</li>
<li>
<p><code>[barBgView valueForKey:@&quot;_backgroundEffectView&quot;];</code></p>
</li>
</ul>
<h2><a id="7-statusbar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. statusBar</h2>
<ul>
<li><code>UIStatusBarStyleDefault</code>枚举值代表含义有变化</li>
</ul>
<pre><code class="language-plain_text">typedef NS_ENUM(NSInteger, UIStatusBarStyle) {
    UIStatusBarStyleDefault                                  = 0, // 根据用户交互样式自动选择状态条样式
    UIStatusBarStyleLightContent     API_AVAILABLE(ios(7.0)) = 1, // Light content, for use on dark backgrounds
    UIStatusBarStyleDarkContent     API_AVAILABLE(ios(13.0)) = 3, // Dark content, for use on light backgrounds
    
    UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1,
    UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2,
} API_UNAVAILABLE(tvos);
</code></pre>
<ul>
<li>定制状态条的样式 使用apple 推荐的这个系统方法</li>
</ul>
<pre><code class="language-plain_text">// ios 13.0 之后，这个方法已经失效了
// [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault];

- (UIStatusBarStyle)preferredStatusBarStyle {
    if (@available(iOS 13.0, *)){
        return UIStatusBarStyleDarkContent;
    }
    return UIStatusBarStyleDefault;
}
</code></pre>
<p><strong>或者 ------&gt;&gt;：</strong></p>
<p><code>UIStatusBarStyleDefault</code> 替换为</p>
<pre><code class="language-plain_text">(@available(iOS 13.0, *) ? UIStatusBarStyleDarkContent : UIStatusBarStyleDefault)
</code></pre>
<p>如果你还是使用的Xcode 10 为了走过编译器这一步，可以使用预编译命令，这么写：</p>
<pre><code class="language-plain_text">#if defined(__IPHONE_13_0) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0
    if (@available(iOS 13.0, *)) {
        [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDarkContent];
    }else{
        [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault];
    }
#else
    [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault];
#endif
</code></pre>
<h2><a id="8-uitabbar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8. UITabbar</h2>
<ul>
<li>横线
UITabbar 层次发生改变，无法通过设置 shadowImage去掉上面的线；</li>
<li>红点
如果之前有通过TabBar上图片位置来设置红点位置，在iOS13上会发现显示位置都在最左边去了。遍历UITabBarButton的subViews发现只有在TabBar选中状态下才能取到UITabBarSwappableImageView，解决办法是修改为通过UITabBarButton的位置来设置红点的frame</li>
</ul>
<h2><a id="9-uisearchbar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9. UISearchBar</h2>
<ul>
<li>UISearchBar的私有属性<code>UISearchBarBackground</code>，禁止访问和remove</li>
</ul>
<pre><code class="language-plain_text">if ([subview isKindOfClass:NSClassFromString(@&quot;UISearchBarBackground&quot;)]) {
    if (@available(iOS 13.0, *)) {
        subview.backgroundColor = [UIColor lightGrayColor];
        // subview.layer.contents = nil;
    }else{
        [subview removeFromSuperview];
    }
}

</code></pre>
<h2><a id="10%E5%A2%9E%E5%8A%A0%E4%B8%80%E7%9B%B4%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E7%9A%84%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>10. 增加一直使用蓝牙的权限申请</h2>
<p><code>info.plist</code>文件下
Key: <code>NSBluetoothAlwaysUsageDescription</code>
Value: <code>我们要一直使用您的蓝牙，具体做什么别问我</code></p>
<h2><a id="11%E6%8E%A8%E9%80%81%E8%8E%B7%E5%8F%96-devicetoken" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>11. 推送 获取deviceToken</h2>
<pre><code class="language-plain_text">#include &lt;arpa/inet.h&gt;
- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
{
    if (![deviceToken isKindOfClass:[NSData class]]) return;
    const unsigned *tokenBytes = [deviceToken bytes];
    NSString *hexToken = [NSString stringWithFormat:@&quot;%08x%08x%08x%08x%08x%08x%08x%08x&quot;,
                          ntohl(tokenBytes[0]), ntohl(tokenBytes[1]), ntohl(tokenBytes[2]),
                          ntohl(tokenBytes[3]), ntohl(tokenBytes[4]), ntohl(tokenBytes[5]),
                          ntohl(tokenBytes[6]), ntohl(tokenBytes[7])];
    NSLog(@&quot;deviceToken:%@&quot;,hexToken);
}
</code></pre>
<h2><a id="12-cncopycurrentnetworkinfo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>12. CNCopyCurrentNetworkInfo</h2>
<pre><code class="language-plain_text"> An app that fails to meet any of the above requirements receives the following return value:

- An app linked against iOS 12 or earlier receives a dictionary with pseudo-values. In this case, the SSID is Wi-Fi (or WLAN in the China region), and the BSSID is 00:00:00:00:00:00.
- An app linked against iOS 13 or later receives NULL.
- 
</code></pre>
<p>iOS13 以后只有开启了 Access WiFi Information capability，才能获取到 SSID 和 BSSID</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fsystemconfiguration%2F1614126-cncopycurrentnetworkinfo%3Flanguage%3Docc">参考：CNCopyCurrentNetworkInfo</a></p>
<h2><a id="13-app%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AF%BC%E8%87%B4-frame%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>13. APP 启动速度优化 导致frame获取失败</h2>
<p>App启动过程中，部分View可能无法实时获取到frame。</p>
<h2><a id="14-wkwebview%E4%B8%AD%E6%B5%8B%E9%87%8F%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E9%AB%98%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%98%E6%9B%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>14. WKWebView 中测量页面内容高度的方式变更</h2>
<p>iOS 13以前 document.body.scrollHeight iOS 13中 document.documentElement.scrollHeight 两者相差55 应该是浏览器定义高度变了</p>
<h2><a id="15-fishhook%E5%AF%BC%E8%87%B4%E7%9A%84-crash" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>15. fishhook 导致的Crash</h2>
<p><a href="https://github.com/facebook/fishhook/issues">github fishhook</a></p>
<h2><a id="16-mpmovieplayercontroller%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%BC%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>16. MPMoviePlayerController 已经被弃用</h2>
<pre><code class="language-plain_text">'MPMoviePlayerController is no longer available. Use AVPlayerViewController in AVKit.' 
</code></pre>
<h2><a id="17-launchimage%E5%8D%B3%E5%B0%86%E6%B6%88%E5%A4%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>17. LaunchImage 即将消失</h2>
<p>从 iOS 8 的时候，苹果就引入了 LaunchScreen，我们可以设置 LaunchScreen来作为启动页。当然，现在你还可以使用LaunchImage来设置启动图。不过使用LaunchImage的话，要求我们必须提供各种屏幕尺寸的启动图，来适配各种设备，随着苹果设备尺寸越来越多，这种方式显然不够 Flexible。而使用 LaunchScreen的话，情况会变的很简单， LaunchScreen是支持AutoLayout+SizeClass的，所以适配各种屏幕都不在话下。
注意啦⚠️，从2020年4月开始，所有使⽤ iOS13 SDK 的 App 将必须提供 LaunchScreen，LaunchImage即将退出历史舞台。</p>
<h2><a id="18-window%E5%B1%82%E7%BA%A7%E5%8F%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>18. window层级变化</h2>
<p>遍历视图获取 keywindow 的方式会失效。
新增了 screenWindow  自定义视图和 keywindow之间新增iOS 13系统的特有图层。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 之 自动打包 fastlane + fir + pgy 【进阶使用】]]></title>
    <link href="http://kaelinda.top/16336621877205.html"/>
    
    <updated>2021-10-08T11:03:07+08:00</updated>
    <id>http://kaelinda.top/16336621877205.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E5%AE%89%E8%A3%85fastlane" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装 fastlane</h2>
<p><a href="https://www.jianshu.com/p/88b9a3e378db">fastlane 安装使用指南</a></p>
<h2><a id="fastlane%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>fastlane 配置项目</h2>
<ul>
<li>
<p>cd 到项目根目录下</p>
</li>
<li>
<p><code>fastlane init</code></p>
</li>
<li>
<p><a href="https://docs.fastlane.tools/advanced/actions/">fastlane action</a></p>
</li>
<li>
<p><a href="https://docs.fastlane.tools/plugins/using-plugins/#fastlane-plugins">fastlane plugin</a></p>
</li>
<li>
<p>gym 请参考：<a href="https://docs.fastlane.tools/actions/gym/">gym官方文档</a></p>
</li>
</ul>
<p><strong>有一点比较坑：每个项目都需要为fastlane配置下环境,关联开发账户</strong></p>
<h2><a id="%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E5%B9%B3%E5%8F%B0%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装打包平台命令工具</h2>
<ul>
<li>安装firim</li>
</ul>
<pre><code class="language-bash">fastlane add_plugin versioning
fastlane add_plugin firim
</code></pre>
<p><code>versioning</code> 需要输入电脑密码，以获取<code>sudo</code>权限.</p>
<p>firim 相关参数可参考：<a href="https://github.com/whlsxl/firim/blob/master/lib/firim/options.rb">firim 源码说明</a></p>
<ul>
<li>安装 fir_cli</li>
</ul>
<pre><code class="language-plain_text">fastlane add_plugin versioning
fastlane add_plugin fir_cli
</code></pre>
<p>fir_cli相关参数可参考 ：<a href="https://github.com/FIRHQ/fastlane-plugin-fir_cli">fir_cli使用说明</a></p>
<ul>
<li>安装蒲公英</li>
</ul>
<p><a href="http://www.pgyer.com/doc/view/fastlane">蒲公英官方文档说明</a>
<a href="https://github.com/shishirui/fastlane-plugin-pgyer">蒲公英插件API说明</a></p>
<pre><code class="language-bash">fastlane add_plugin pgyer
</code></pre>
<p>需要输入 y,以确认安装.</p>
<ul>
<li>
<p>Pluginfile</p>
<p>此时 fastlane/Pluginfile 文件内应该是这样子的：</p>
<pre><code class="language-bash">gem 'fastlane-plugin-pgyer'
gem 'fastlane-plugin-versioning'
gem 'fastlane-plugin-firim'
</code></pre>
</li>
<li>
<p>fastlane action</p>
</li>
</ul>
<p>定义一个 Action 叫 <code>PY_release</code>:</p>
<pre><code class="language-plain_text">lane :PY_release do |options|
    gym(
      clean:true, #打包前clean项目
      silent:true,
      export_method: &quot;development&quot;, #导出方式
      scheme:&quot;LXPeiyou&quot;, #scheme
      configuration: options[:configuration],#环境
      output_directory:&quot;./AppOutput&quot;,#ipa的存放目录
      output_name:&quot;********&quot;#输出ipa的文件名为当前的build号
      )
    
    # 自己的fir账号
    # firim(firim_api_token:'*****', app_changelog:options[:update_info])
    
    #蒲公英的配置 替换为自己的api_key和user_key
    # pgyer(api_key: &quot;******&quot;, user_key: &quot;******&quot;,update_description: options[:update_info])
  end
</code></pre>
<p><strong>外部调用</strong>
执行Action 并传参：</p>
<pre><code class="language-bash">fastlane PY_release configuration:$configuration update_info:$update_info
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios 之 自动打包 脚本 【bash 版本】]]></title>
    <link href="http://kaelinda.top/16336621451455.html"/>
    
    <updated>2021-10-08T11:02:25+08:00</updated>
    <id>http://kaelinda.top/16336621451455.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置打包信息</h2>
<pre><code class="language-bash"># 工程名称
kProjectName=&quot;ipa.xcodeproj&quot;

# workspace 名称 如果使用了cocopods等可能需要用工作空间方式打包
# workspaceName=“ipa.workspace”

# scheme名称
kSchemeName=&quot;ipa&quot;

# target 这里scheme只对应了一个target运行；如果有多个target需要指定target
kTargetName=&quot;ipa&quot;

# APP环境配置 Configuration
kConfiguration=&quot;Release&quot;

# archive导出路径
kArchivePath=&quot;./ipaOutput/${kSchemeName}.xcarchive&quot;

# ipa导出路径
kExport_ipa_Path=&quot;./ipaOutput/${kSchemeName}&quot;

# 不同的打包方式这个导出文件不同 [这个文件很重要，他决定了你的包是否能够正常导出] 
# 用Xcode自带的archive方式导出ipa的时候，这个文件会随之导出
kExportOptionsPlist=&quot;./ipaOutput/ExportOptions.plist&quot;

kAppChangelog=&quot;Tips:我是版本更新信息&quot;
</code></pre>
<h2><a id="%E6%89%93%E5%8C%85%E5%AF%BC%E5%87%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打包 &amp;&amp; 导出</h2>
<pre><code class="language-bash"># clean
xcodebuild  clean -configuration &quot;$configuration&quot; -alltargets

# archive project
xcodebuild archive -project &quot;$kProjectName&quot; -scheme &quot;$kSchemeName&quot; -configuration &quot;$kConfiguration&quot; -archivePath &quot;$kArchivePath&quot;

# archive workspace
# #xcodebuild  archive  -workspace &quot;$workspaceName&quot; -scheme &quot;$scheme&quot; -configuration  &quot;$kConfiguration&quot;  -archivePath &quot;$kArchivePath&quot;  

# 导出ipa
xcodebuild -exportArchive -archivePath &quot;$kArchivePath&quot; -exportOptionsPlist &quot;$kExportOptionsPlist&quot; -exportPath &quot;$kExport_ipa_Path&quot;
</code></pre>
<h2><a id="%E4%B8%8A%E4%BC%A0ipa%E5%88%B0%E5%88%86%E5%8F%91%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传ipa到分发平台</h2>
<pre><code class="language-bash"># --------------&gt; 检测IPA存在否
ipa_path=&quot;${kExport_ipa_Path}/${kSchemeName}.ipa&quot;

if [ -f &quot;$ipa_path&quot; ]
	then
		echo &quot;------------ipa存在😁......&quot;
	else
		echo &quot;------------ipa不存在😭......&quot;
		exit 1
fi
</code></pre>
<h3><a id="%E4%B8%8A%E4%BC%A0%E5%88%B0fir" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传到fir</h3>
<pre><code class="language-bash"># --------- firm 上传配置

echo &quot;请选择登录账户名：\n 1）kael 自己的fir账户（默认） \n 2）公司的fir账户&quot;

read fir_token

if [[ $fir_token == 2 ]]; then
  #公司账号
  fir_token=&quot;*********&quot;
else
  # 自己的账号
  fir_token=&quot;*********&quot;
fi

fir publish ${ipa_path} -T $fir_token -c $kAppChangelog
</code></pre>
<h3><a id="%E4%B8%8A%E4%BC%A0%E5%88%B0pgy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传到pgy</h3>
<pre><code class="language-bash"># -------- pgy 上传

echo &quot;------------准备发布蒲公英------------&quot;
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;蒲公英账号信息配置
#蒲公英账号
pgy_API_Key=&quot;*********&quot;
pgy_User_Key=&quot;*********&quot;


# ------&gt; 蒲公英发布
curl -F &quot;file=@$ipa_path&quot; \
-F &quot;uKey=$pgy_User_Key&quot; \
-F &quot;_api_key=$pgy_API_Key&quot; \
-F &quot;updateDescription=$kAppChangelog&quot; \
https://www.pgyer.com/apiv1/app/upload
</code></pre>
<h2><a id="%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚本</h2>
<pre><code class="language-bash">#!/bin/sh

# 工程名称
kProjectName=&quot;ipa.xcodeproj&quot;

# workspace 名称 如果使用了cocopods等可能需要用工作空间方式打包
# workspaceName=“ipa.workspace”

# scheme名称
kSchemeName=&quot;ipa&quot;

# target 这里scheme只对应了一个target运行；如果有多个target需要指定target
kTargetName=&quot;ipa&quot;

# APP环境配置
kConfiguration=&quot;Release&quot;

# archive导出路径
kArchivePath=&quot;./ipaOutput/${kSchemeName}.xcarchive&quot;

# ipa导出路径
kExport_ipa_Path=&quot;./ipaOutput/${kSchemeName}&quot;

# 不同的打包方式这个导出文件不同
kExportOptionsPlist=&quot;./ipaOutput/ExportOptions.plist&quot;

kAppChangelog=&quot;Tips:我是版本更新信息&quot;


# ------------------&gt; 打包区
# clean
xcodebuild  clean -configuration &quot;$configuration&quot; -alltargets

# archive project
xcodebuild archive -project &quot;$kProjectName&quot; -scheme &quot;$kSchemeName&quot; -configuration &quot;$kConfiguration&quot; -archivePath &quot;$kArchivePath&quot;

# archive workspace
# #xcodebuild  archive  -workspace &quot;$workspaceName&quot; -scheme &quot;$scheme&quot; -configuration  &quot;$kConfiguration&quot;  -archivePath &quot;$kArchivePath&quot;  

# 导出ipa
xcodebuild -exportArchive -archivePath &quot;$kArchivePath&quot; -exportOptionsPlist &quot;$kExportOptionsPlist&quot; -exportPath &quot;$kExport_ipa_Path&quot;


# --------------&gt; 检测IPA存在否
ipa_path=&quot;${kExport_ipa_Path}/${kSchemeName}.ipa&quot;

if [ -f &quot;$ipa_path&quot; ]
	then
		echo &quot;------------ipa存在😁......&quot;
	else
		echo &quot;------------ipa不存在😭......&quot;
		exit 1
fi

# --------- firm 上传配置

echo &quot;请选择登录账户名：\n 1）kael 自己的fir账户（默认） \n 2）公司的fir账户&quot;

read fir_token

if [[ $fir_token == 2 ]]; then
  #公司账号
  fir_token=&quot;*********&quot;
else
  # 自己的账号
  fir_token=&quot;*********&quot;
fi

fir publish ${ipa_path} -T $fir_token -c $kAppChangelog

# -------- pgy 上传

echo &quot;------------准备发布蒲公英------------&quot;
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;蒲公英账号信息配置
#蒲公英账号
pgy_API_Key=&quot;*********&quot;
pgy_User_Key=&quot;*********&quot;


# ------&gt; 蒲公英发布
curl -F &quot;file=@$ipa_path&quot; \
-F &quot;uKey=$pgy_User_Key&quot; \
-F &quot;_api_key=$pgy_API_Key&quot; \
-F &quot;updateDescription=$kAppChangelog&quot; \
https://www.pgyer.com/apiv1/app/upload
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 11 Xib `_UITextLayoutView` 崩溃]]></title>
    <link href="http://kaelinda.top/16336621349772.html"/>
    
    <updated>2021-10-08T11:02:14+08:00</updated>
    <id>http://kaelinda.top/16336621349772.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<p>崩溃信息如下：</p>
<pre><code class="language-plain_text">*** Terminating app due to uncaught exception 
'NSInvalidUnarchiveOperationException', 
reason: 'Could not instantiate class named _UITextLayoutView because no class named _UITextLayoutView was found; 
the class needs to be defined in source code or linked in from a library (ensure the class is part of the correct target)'
</code></pre>
<p>解决方案：</p>
<h2><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案 一</h2>
<p>xib的部分视图改用硬核手写，以避坑。</p>
<h2><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案 二</h2>
<p><a href="https://developer.apple.com/download/more">下载其他版本Xcode 传送门</a></p>
<h2><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案 三</h2>
<p>OC 黑魔法 <code>Runtime</code>。</p>
<ul>
<li>
<p>创建 文件 <code>UITextViewWorkaround</code></p>
</li>
<li>
<p>UITextViewWorkaround.h</p>
</li>
</ul>
<pre><code class="language-plain_text">#import &lt;Foundation/Foundation.h&gt;

@interface UITextViewWorkaround : NSObject
+ (void)executeWorkaround; 
@end

</code></pre>
<ul>
<li>UITextViewWorkaround.m</li>
</ul>
<pre><code class="language-plain_text">#import &quot;UITextViewWorkaround.h&quot;
#import  &lt;objc/runtime.h&gt;



@implementation UITextViewWorkaround

+ (void)executeWorkaround {
    if (@available(iOS 13.2, *)) {

    }
    else {
        const char *className = &quot;_UITextLayoutView&quot;;
        Class cls = objc_getClass(className);
        if (cls == nil) {
            cls = objc_allocateClassPair([UIView class], className, 0);
            objc_registerClassPair(cls);
#if DEBUG
            printf(&quot;added %s dynamically\n&quot;, className);
#endif
        }
    }
}

@end
</code></pre>
<ul>
<li>使用该静态方法</li>
</ul>
<pre><code class="language-plain_text">#import &quot;UITextViewWorkaround.h&quot;

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.

    [UITextViewWorkaround executeWorkaround];
    return yes;
}
</code></pre>
<ul>
<li>swift 版本请客观收下：</li>
</ul>
<pre><code class="language-plain_text">import UIKit

@objc
class UITextViewWorkaround : NSObject {

    static func executeWorkaround() {
        if #available(iOS 13.2, *) {
        } else {
            let className = &quot;_UITextLayoutView&quot;
            let theClass = objc_getClass(className)
            if theClass == nil {
                let classPair: AnyClass? = objc_allocateClassPair(UIView.self, className, 0)
                objc_registerClassPair(classPair!)
            }
        }
    }

}
</code></pre>
<p><a href="https://stackoverflow.com/questions/58657087/after-upgrading-to-xcode-11-2-from-xcode-11-1-app-crashes-due-to-uitextlayoutv">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios 之 自动打包 一键打包脚本 【bash优化版本】]]></title>
    <link href="http://kaelinda.top/16336619273999.html"/>
    
    <updated>2021-10-08T10:58:47+08:00</updated>
    <id>http://kaelinda.top/16336619273999.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<h2><a id="%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85scheme" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>选择打包scheme</h2>
<pre><code class="language-bash"># 选择打包环境
function selectedScheme() {
  #statements
  echo &quot;请选择打包对象: \n 1) GaoKao(**高考) \n 2) Zhongkao(**中考)&quot;
  read app_scheme

  if [[ $app_scheme == 1 ]]; then
    echo &quot;您选择的是：GaoKao(**高考)&quot;
    app_scheme=&quot;GaoKao&quot;
  elif [[ $app_scheme == 2 ]]; then
    echo &quot;您选择的是：Zhongkao(**中考)&quot;
    app_scheme=&quot;Zhongkao&quot;
  else
    selectedScheme
  fi
}
</code></pre>
<h2><a id="%E9%80%89%E6%8B%A9%E6%89%93%E5%8C%85%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>选择打包环境</h2>
<pre><code class="language-bash">function selectedConfiguration() {
  #statements
  echo &quot;-- 😁 --\n&quot;
  echo &quot;--\n&quot;
  echo &quot;请选择打包环境:\n 1)Release \n 2)LXRelease_dev \n 3)LXRelease_kfc \n 4)LXRelease_tsl&quot;

  read configuration

  if [[ $configuration == 1 ]]; then
    echo &quot;您选择的是Release环境&quot;
    configuration=&quot;Release&quot;
  elif [[ $configuration == 2 ]]; then
    echo &quot;您选择的是LXRelease_dev环境&quot;
    configuration=&quot;LXRelease_dev&quot;
  elif [[ $configuration == 3 ]]; then
    echo &quot;您选择的是LXRelease_kfc环境&quot;
    configuration=&quot;LXRelease_kfc&quot;
  elif [[ $configuration == 4 ]]; then
    echo &quot;您选择的是LXRelease_tsl环境&quot;
    configuration=&quot;LXRelease_tsl&quot;
  else
    selectedConfiguration
  fi
}
</code></pre>
<h2><a id="%E8%AF%BB%E5%8F%96%E6%9B%B4%E6%96%B0%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读取更新信息</h2>
<pre><code class="language-bash">function readUpdateInfo() {
  echo &quot;-\n&quot;
  echo &quot;--\n&quot;
  echo &quot;请输入您当前版本更新信息:&quot;

  read update_info
}
</code></pre>
<h2><a id="%E6%89%93%E5%8D%B0%E6%89%93%E5%8C%85%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打印打包信息</h2>
<pre><code class="language-bash">function logPackageInfo() {
  echo &quot;打包信息----------&gt;:\n&quot;
  echo &quot;打包scheme是   --&gt;: ${app_scheme}&quot;
  echo &quot;您选择的是     --&gt;: ${configuration}&quot;
  echo &quot;版本更新信息   --&gt;: ${update_info}&quot;
}
</code></pre>
<h2><a id="%E4%B8%8A%E4%BC%A0dsym%E5%88%B0bugly%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传dSYM到bugly进行分析</h2>
<pre><code class="language-bash"># --------------------&gt;&gt; 上传 dSYM 文件
function uploaddSYMFile() {
  #statements
  echo &quot;bugly --- start......&quot;

  output_file_name=&quot;&quot;
  bugly_appName=&quot;&quot;
  bugly_configName=&quot;&quot;

  if [[ ${app_scheme} = &quot;GaoKao&quot; ]]; then
    bugly_appName=&quot;**高考&quot;
  elif [[ ${app_scheme} == &quot;Zhongkao&quot; ]]; then
    bugly_appName=&quot;**中考&quot;
  fi

  if [[ ${configuration} = &quot;LXRelease&quot; ]]; then
    bugly_configName=&quot;&quot;
  elif [[ ${configuration} = &quot;LXRelease_dev&quot; ]]; then
    bugly_configName=&quot;dev&quot;
  elif [[ ${configuration} = &quot;LXRelease_tsl&quot; ]]; then
    bugly_configName=&quot;tsl&quot;
  elif [[ ${configuration} = &quot;LXRelease_kfc&quot; ]]; then
    bugly_configName=&quot;kfc&quot;
  fi

  output_file_name=&quot;${app_scheme}_${configuration}&quot;

  bugly_dsym_zip_path=&quot;./AppOutput/${output_file_name}.app.dSYM.zip&quot;

  echo &quot;kael ------rm&quot;
  # rm &quot;./AppOutput/dsym_upload/&quot;
  find &quot;./AppOutput/dsym_upload/&quot; -name &quot;*.dSYM&quot; | xargs rm -rf
  find &quot;./AppOutput/&quot; -name &quot;dsym_upload.zip&quot; | xargs rm -rf
  echo &quot;kael ------rm -- end&quot;

  # 解压文件
  echo &quot;kael ------unzip&quot;
  echo &quot;path -- $bugly_dsym_zip_path&quot;
  unzip ${bugly_dsym_zip_path} -d &quot;./AppOutput/dsym_upload/&quot;

  bugly_java_path=&quot;./buglySymboliOS/buglySymboliOS.jar&quot;
  bugly_dsym_path=&quot;./AppOutput/dsym_upload/&quot;
  echo &quot;${bugly_dsym_path}&quot;

  echo &quot;kael ------upload start&quot;
  java -jar $bugly_java_path -i $bugly_dsym_path -dsym -u -id 900058462 -key f8V5dgJO5em0CPPk -package com.lexue.lexuegaokao -version 3.3.3

}
</code></pre>
<h2><a id="%E6%99%AE%E9%80%9A%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>普通打包</h2>
<pre><code class="language-bash"># --------------------&gt;&gt;  普通打包任务
function normal_archive() {
  #statements
  selectedScheme
  # # 等待 沉睡
  # sleep 0.5s
  # 选择打包环境
  selectedConfiguration
  # 等待 沉睡
  sleep 0.5s
  # 读取版本更新信息
  readUpdateInfo
  # 等待 沉睡
  sleep 0.5s
  # 打印更新信息
  logPackageInfo

  fastlane ipa_release scheme:$app_scheme configuration:$configuration update_info:$update_info

  logPackageInfo

  uploaddSYMFile

}
</code></pre>
<h2><a id="%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%A4%9Ascheme%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多环境 多scheme 打包</h2>
<pre><code class="language-bash"># --------------------&gt;&gt; 单个打包任务
function one_serial_archive() {
  app_scheme=$1
  configuration=$2
  update_info=$3
  #打印信息
  logPackageInfo
  # 打包导出
  fastlane ipa_release scheme:$app_scheme configuration:$configuration update_info:$update_info
  # 打印信息
  logPackageInfo
  # 上传dSYM
  uploaddSYMFile
} 
# --------------------&gt;&gt; 多个打包任务
function serial_archive() {
  readUpdateInfo

  # 中考
  one_serial_archive &quot;Zhongkao&quot; &quot;Release&quot; $update_info
  one_serial_archive &quot;Zhongkao&quot; &quot;LXRelease_dev&quot; $update_info
  one_serial_archive &quot;Zhongkao&quot; &quot;LXRelease_kfc&quot; $update_info
  one_serial_archive &quot;Zhongkao&quot; &quot;LXRelease_tsl&quot; $update_info
  # 高考
  one_serial_archive &quot;GaoKao&quot; &quot;Release&quot; $update_info
  one_serial_archive &quot;GaoKao&quot; &quot;LXRelease_dev&quot; $update_info
  one_serial_archive &quot;GaoKao&quot; &quot;LXRelease_kfc&quot; $update_info
  one_serial_archive &quot;GaoKao&quot; &quot;LXRelease_tsl&quot; $update_info
}
</code></pre>
<h2><a id="%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚本使用</h2>
<pre><code class="language-bash"># 打包一系列环境的包
serial_archive
</code></pre>
<p>命令行工具中输入<code>sh ipa.sh</code>即可</p>
<h2><a id="%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件共享</h2>
<p>buly文件链接:<a href="https://pan.baidu.com/s/13jaP6Jggp6DcDwqXYeEjHg">https://pan.baidu.com/s/13jaP6Jggp6DcDwqXYeEjHg</a>  密码:lowx
JDK(java环境安装文件)链接:<a href="https://pan.baidu.com/s/1NtGdP0cANQz7TtyYU2mycg">https://pan.baidu.com/s/1NtGdP0cANQz7TtyYU2mycg</a>  密码:f6af</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iPad 横屏启动 界面错乱 解决方案]]></title>
    <link href="http://kaelinda.top/16336618881036.html"/>
    
    <updated>2021-10-08T10:58:08+08:00</updated>
    <id>http://kaelinda.top/16336618881036.html</id>
    <content type="html"><![CDATA[
    <img src="" />
<blockquote>
<p>现象：iPad 开启屏幕旋转，横屏启动APP，某些特殊情况下，APP会变成横屏APP。恭喜你，中奖了，这时候即使你ViewController的控制屏幕旋转的三个代理方法都只支持竖屏，你的APP也可能是错乱的。</p>
</blockquote>
<ul>
<li>神奇的解决方案：
<ul>
<li><code>mainScreen</code>添加一个window，<code>makeKeyAndVisible</code></li>
<li>然后<code>resignKeyWindow</code></li>
</ul>
</li>
</ul>
<pre><code class="language-plain_text">- (void)showMagicWindow{
    UIWindow *aawindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
       aawindow.backgroundColor = [UIColor clearColor];
       aawindow.windowLevel = UIWindowLevelAlert;
       [aawindow makeKeyAndVisible];
    [aawindow resignKeyWindow];
       aawindow.hidden = YES;
       aawindow = nil;
}
</code></pre>
<p>哪位大神能解释下？</p>

]]></content>
  </entry>
  
</feed>
